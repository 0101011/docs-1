======================
Create Tailable Cursor
======================

.. default-domain:: mongodb

Overview
--------

By default, MongoDB will automatically close a cursor if the cursor has
been exhausted. However, with :doc:`capped collections
</core/capped-collections>`, you can create a *Tailable Cursor* which
remains open after the cursor has been exhausted. Similar to the Unix
``tail -f`` command, the tailable cursor "tails" the end of a capped
collection. After new documents are inserted into the capped
collection, you can use the tailable cursor to continue retrieving
documents.

Use tailable cursors on capped collections with high numbers of write
operations for which an index would be too expensive. For instance,
MongoDB :doc:`replication </core/replication>` uses tailable cursors to
tail the primary's :term:`oplog`.

If your query is on an indexed field, do not use tailable cursors, but
instead, use a regular cursor. Keep track of the last value of the
indexed field returned by the query. To retrieve the newly added
documents, query the collection again using the last value of the
indexed field in the query criteria, as in the following example:

.. code-block:: javascript

   db.mycollection.find( { indexedField: { $gt: <lastvalue> } } )

Consider the following behaviors related to tailable cursors:

- Tailable cursors do not use indexes and return documents in
  :term:`natural order`.

- Because tailable cursors do not use indexes, the initial scan for the
  query may be expensive; but, after initially exhausting the cursor,
  subsequent retrievals of the newly added documents are inexpensive.

- Tailable cursors may become *dead*, or invalid, if either:

  - the query returned no match.
  
  - the last returned object is at the end of the collection and is
    deleted.

  A *dead* cursor has an id of ``0``. 
  
See your :doc:`driver documentation </applications/drivers>` for the
driver-specific method to specify the tailable cursor.
[#tailable-cursor-wire-protocol]_

.. [#tailable-cursor-wire-protocol] For more information on the details
   of specifying a tailable cursor, see :wiki:`Mongo wire protocol <Mongo Wire
   Protocol>` documentation.

C++ Example
-----------

The ``tail`` function uses a tailable cursor to output the results from
a query to a capped collection:

- The function handles the case of the dead cursor by having the query
  be inside a loop. 

- To periodically check for new data, the ``cursor->more()`` statement
  is also inside a loop.

.. code-block:: cpp

   #include "client/dbclient.h"

   using namespace mongo;

   /* 
    * Example of a tailable cursor.
    * The function "tails" the capped collection (ns) and output elements as they are added.
    * The function also handles the possibility of a dead cursor by tracking the field 'insertDate'.
    * New documents are added with increasing values of 'insertDate'.
    */

   void tail(DBClientBase& conn, const char *ns) {

       BSONElement lastValue = minKey.firstElement();

       Query query = Query().hint( BSON( "$natural" << 1 ) ); 

       while ( 1 ) {
           auto_ptr<DBClientCursor> c =
               conn.query(ns, query, 0, 0, 0,
                          QueryOption_CursorTailable | QueryOption_AwaitData );

           while ( 1 ) {
               if ( !c->more() ) {

                   if ( c->isDead() ) {
                       break;
                   }

                   continue;
               }

               BSONObj o = c->next();
               lastValue = o["insertDate"];
               cout << o.toString() << endl;
           }

           query = QUERY( "insertDate" << GT << lastValue ).hint( BSON( "$natural" << 1 ) );
       }
   }

The ``tail`` function performs the following actions:

- Initialize the ``lastValue`` variable, which tracks the last accessed
  value and will be used if the cursor becomes *dead* and we need to
  requery. Use ``hint()`` to ensure that the ``$natural`` order is used.

- In an outer ``while(1)`` loop,

  - Query the capped collection and return a tailable cursor that
    blocks for several seconds waiting for new documents

    .. code-block:: cpp

       auto_ptr<DBClientCursor> c = 
            conn.query(ns, query, 0, 0, 0,
                       QueryOption_CursorTailable | QueryOption_AwaitData );

    - The capped collection is specified by ``ns`` and is an argument
      to the function.

    - The function sets the ``QueryOption_CursorTailable`` option to
      specify that the returned cursor is a tailable cursor.

    - The function sets the ``QueryOption_AwaitData`` option to specify
      that the returned cursor should block for a few seconds to wait
      for data.

  - In an inner ``while (1)`` loop, read the documents from the cursor:

    - If the cursor has no more documents and is not dead, loop the
      inner ``while`` loop to recheck for more documents.

    - If the cursor has no more documents and is dead, break the inner
      ``while`` loop.

    - If the cursor has documents,
      
      - output the document,
      
      - update the ``lastValue`` value,
      
      - and loop the inner ``while (1)`` loop to recheck for more
        documents.

  - If the logic breaks out of the inner ``while (1)`` loop (i.e. the
    cursor is dead):

    - Use the ``lastValue`` value to create a new query condition that
      matches documents added after the ``lastValue``. Explicitly
      ensure ``$natural`` order with the ``hint()`` method:

      .. code-block:: cpp

         query = QUERY( "insertDate" << GT << lastValue ).hint( BSON( "$natural" << 1 ) );

    - Loop through the outer ``while (1)`` loop to re-query with the new query
      condition and repeat.

JavaScript Example
------------------

The JavaScript example uses a tailable cursor to output the results
from a query of a capped collection named ``myCappedCollection``. To
periodically check for new data, the ``cursor->hasNext()`` statement is
inside a loop:

.. code-block:: javascript

   var coll = db.myCappedCollection;

   var startDoc = coll.find().hint( { '$natural': 1 } ).limit(1).next();
   var lastValue = startDoc['insertDate'];
   printjson(startDoc)

   while (1) {

       var cursor = coll.find( { 'insertDate' : { '$gt' : lastValue } } ).hint( { '$natural': 1 } );

       cursor.addOption( DBQuery.Option.tailable );

       cursor.addOption( DBQuery.Option.awaitData );

       while ( cursor.hasNext() ) {
          var doc = cursor.next();
          lastValue = doc['insertDate'];
          printjson(doc); 
       }
   }

The example performs the following actions:

- Query the capped collection to access the first document inserted.
  The query uses the :method:`hint() <cursor.hint()>` method to ensure
  the use of the insertion order.

- Initialize the ``lastValue`` variable to hold the last accessed value
  of the unindexed field ``insertDate``. Newly added documents contain
  increasing values for the ``insertDate`` field.

- In an outer ``while (1)`` loop,

  - Query the capped collection for documents with the field
    ``insertDate`` greater than the ``lastValue``. The query uses the
    :method:`hint() <cursor.hint()>` method to ensure that the
    insertion order is used.

  - Specify that the returned cursor should be a tailable cursor:

    .. code-block:: javascript

       cursor.addOption( DBQuery.Option.tailable );

    See your :doc:`driver documentation </applications/drivers>` for
    the driver-specific method to specify a tailable cursor.

  - Specify that the cursor should block for a few seconds to wait for
    data:

    .. code-block:: javascript

       cursor.addOption( DBQuery.Option.awaitData );

    See your :doc:`driver documentation </applications/drivers>` for
    the driver-specific method to specify that the cursor should wait
    for data.

  - In an inner ``while (cursor.hasNext())`` loop,

    - retrieve the document, 

    - update the ``lastValue`` variable, 

    - print the document,

    - and loop to recheck for more documents.

  - If there are no more documents, repeat the outer loop.
