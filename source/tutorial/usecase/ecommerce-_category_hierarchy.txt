E-Commerce: Category Hierarchy
==============================

Problem
-------

You have a product hierarchy for an e-commerce site that you want to
query frequently and update somewhat frequently.

Solution overview
-----------------

We will keep each category in its own document, along with a list of its
ancestors. The category hierarchy we will use in this solution will be
based on different categories of music:

.. figure:: https://docs.google.com/a/arborian.com/drawings/image?id=sYoXu6LHwYVB_WXz1Y_k8XA&rev=27&h=250&w=443&ac=1
   :align: center
   :alt:
Since categories change relatively infrequently, we will focus mostly in
this solution on the operations needed to keep the hierarchy up-to-date
and less on the performance aspects of updating the hierarchy.

Schema design
-------------

Each category in our hierarchy will be represented by a document. That
document will be identified by an ObjectId for internal
cross-referencing as well as a human-readable name and a url-friendly
'slug' property. Additionally, we will store an ancestors list along
with each document to facilitate displaying a category along with all
its ancestors in a single query.

::

    { "_id" : ObjectId("4f5ec858eb03303a11000002"),
      "name" : "Modal Jazz",
      "parent" : ObjectId("4f5ec858eb03303a11000001"),
      "slug" : "modal-jazz",
      "ancestors" : [
             { "_id" : ObjectId("4f5ec858eb03303a11000001"),
            "slug" : "bop",
            "name" : "Bop" },
             { "_id" : ObjectId("4f5ec858eb03303a11000000"),
               "slug" : "ragtime",
               "name" : "Ragtime" } ]
    }

Operations
----------

Here, we will describe the various queries and updates we will use
during the lifecycle of our hierarchy.

Read and display a category
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The simplest operation is reading and displaying a hierarchy. In this
case, we might want to display a category along with a list of 'bread
crumbs' leading back up the hierarchy. In an E-commerce site, we will
most likely have the slug of the category available for our query.

::

    category = db.categories.find(
        {'slug':slug},
        {'_id':0, 'name':1, 'ancestors.slug':1, 'ancestors.name':1 })

Here, we use the slug to retrieve the category and retrieve only those
fields we wish to display.

Index Support
^^^^^^^^^^^^^

In order to support this common operation efficiently, we need an index
on the 'slug' field. Since slug is also intended to be unique, we will
add that constraint to our index as well:

::

    db.categories.ensure_index('slug', unique=True)

Add a category to the hierarchy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adding a category to a hierarchy is relatively simple. Suppose we wish
to add a new category 'Swing' as a child of 'Ragtime': |image0|

In this case, the initial insert is simple enough, but after this
insert, we are still missing the ancestors array in the 'Swing'
category. To define this, we will add a helper function to build our
ancestor list:

::

    def build_ancestors(_id, parent_id):
        parent = db.categories.find_one(
            {'_id': parent_id},
            {'name': 1, 'slug': 1, 'ancestors':1})
        parent_ancestors = parent.pop('ancestors')
        ancestors = [ parent ] + parent_ancestors
        db.categories.update(
            {'_id': _id},
            {'$set': { 'ancestors': ancestors } })

Note that we only need to travel one level in our hierarchy to get the
ragtime's ancestors and build swing's entire ancestor list. Now we can
actually perform the insert and rebuild the ancestor list:

::

    doc = dict(name='Swing', slug='swing', parent=ragtime_id)
    swing_id = db.categories.insert(doc)
    build_ancestors(swing_id, ragtime_id)

Index Support
^^^^^^^^^^^^^

Since these queries and updates all selected based on \_id, we only need
the default MongoDB-supplied index on \_id to support this operation
efficiently.

Change the ancestry of a category
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our goal here is to reorganize the hierarchy by moving 'bop' under
'swing':

.. figure:: https://docs.google.com/a/arborian.com/drawings/image?id=sFB8ph8n7c768f-MLTOkY-w&rev=6&h=354&w=443&ac=1
   :align: center
   :alt:
The initial update is straightforward:

::

    db.categories.update(
        {'_id':bop_id}, {'$set': { 'parent': swing_id } } )

Now, we need to update the ancestor list for bop and all its
descendants. In this case, we can't guarantee that the ancestor list of
the parent category is always correct, however (since we may be
processing the categories out-of-order), so we will need a new
ancestor-building function:

::

    def build_ancestors_full(_id, parent_id):
        ancestors = []
        while parent_id is not None:
            parent = db.categories.find_one(
                {'_id': parent_id},
                {'parent': 1, 'name': 1, 'slug': 1, 'ancestors':1})
            parent_id = parent.pop('parent')
            ancestors.append(parent)
        db.categories.update(
            {'_id': _id},
            {'$set': { 'ancestors': ancestors } })

Now, at the expense of a few more queries up the hierarchy, we can
easily reconstruct all the descendants of 'bop':

::

    for cat in db.categories.find(
        {'ancestors._id': bop_id},
        {'parent_id': 1}):
        build_ancestors_full(cat['_id'], cat['parent_id'])

Index Support
^^^^^^^^^^^^^

In this case, an index on 'ancestors.\_id' would be helpful in
determining which descendants need to be updated:

::

    db.categories.ensure_index('ancestors._id')

Renaming a category
~~~~~~~~~~~~~~~~~~~

Renaming a category would normally be an extremely quick operation, but
in this case due to our denormalization, we also need to update the
descendants. Here, we will rename 'Bop' to 'BeBop':

|image1| First, we need to update the category name itself:

::

    db.categories.update(
        {'_id':bop_id}, {'$set': { 'name': 'BeBop' } } )

Next, we need to update each descendant's ancestors list:

::

    db.categories.update(
        {'ancestors._id': bop_id},
        {'$set': { 'ancestors.$.name': 'BeBop' } },
        multi=True)

Here, we use the positional operation '$' to match the exact 'ancestor'
entry that matches our query, as well as the 'multi' option on our
update to ensure the rename operation occurs in a single server
round-trip.

Index Support
^^^^^^^^^^^^^

In this case, the index we have already defined on 'ancestors.\_id' is
sufficient to ensure good performance.

Sharding
--------

In this solution, it is unlikely that we would want to shard the
collection since it's likely to be quite small. If we *should* decide to
shard, the use of an \_id field for most of our updates makes \_id an
ideal sharding candidate. The sharding commands we would use to shard
the category collection would then be the following:

::

    >>> db.command('shardcollection', 'categories')
    { "collectionsharded" : "categories", "ok" : 1 }

Note that there is no need to specify the shard key, as MongoDB will
default to using \_id as a shard key.

.. |image0| image:: https://docs.google.com/a/arborian.com/drawings/image?id=sRXRjZMEZDN2azKBlsOoXoA&rev=7&h=250&w=443&ac=1
.. |image1| image:: https://docs.google.com/a/arborian.com/drawings/image?id=sqRIXKA2lGr_bm5ysM7KWQA&rev=3&h=354&w=443&ac=1
