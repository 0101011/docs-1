===
$or
===

.. default-domain:: mongodb

.. operator:: $or

   .. versionadded:: 1.6

   .. versionchanged:: 2.0
      You may nest :operator:`$or` operations; however, these
      expressions are not as efficiently optimized as top-level.

   *Syntax*: ``{ $or: [ { <expression1> }, { <expression2> }, ... , { <expressionN> } ] }``

   The :operator:`$or` operator performs a logical ``OR`` operation on an array of
   *two or more* ``<expressions>`` and selects the documents that satisfy
   *at least* one of the ``<expressions>``.

   For example, the following query selects all documents in ``inventory`` where:
   
   - ``price`` equals ``1.99`` **and** 
   - either ``qty`` is less than ``20`` *or* ``sale`` is ``true``.

   .. code-block:: javascript
        
      db.inventory.find( { price:1.99, $or: [ { qty: { $lt: 20 } }, { sale: true } ] } )
			
   You could also write the same query using the explicit :operator:`$and` operator as: 

   .. code-block:: javascript
			
      db.inventory.find( { $and: [ {price:1.99}, { $or: [ { qty: { $lt: 20 } }, { sale: true } ] } ] } )

   Additionally, you may use the :operator:`$or` operator to select
   fields from embedded documents.
   
   For example, the following query updates a single document in
   ``inventory`` where:
   
      - ``price`` equals ``1.99`` **or** 
      - ``carrier.state`` equals ``NY``.

   .. code-block:: javascript
 
      db.inventory.update( { $or: [ { price:10.99 }, { "carrier.state": "NY"} ] }, { $set: { sale: true } } )
   
   When using :operator:`$or` with ``<expressions>`` that are
   equality checks for the **same** key, using :operator:`$in` is
   preferred over :operator:`$or`.  
   
   For example, to select all documents in ``inventory`` where: 
   
   - either ``price`` equals ``1.99`` *or* ``sale`` is ``true``, **and**
   - either ``qty`` equals ``20`` *or*  ``qty`` equals ``50``,
   
   the most effective query would be:
   
   .. code-block:: javascript
  
      db.inventory.find ( { $or: [ { price: 1.99 }, { sale: true } ], qty: { $in: [20, 50] } } )

   Consider the following behaviors when using the :operator:`$or`
   operator:
   
   - When using indexes with :operator:`$or` queries, remember that
     each clause of an :operator:`$or` query will execute in parallel.
     These clauses can each use their own index. This means that for
     the query:

      .. code-block:: javascript

         db.inventory.find ( { $or: [ { price: 1.99 }, { sale: true } ] } )

     you would create one index on ``price``
     ( ``db.inventory.ensureIndex( { price: 1 } )`` ) and another index on
     ``sale`` ( ``db.inventory.ensureIndex( { sale: 1 } )`` )
     rather than a compound index. 

   - Also, when using :operator:`$or` with :method:`sort()
     <cursor.sort()>` in a query, the query will *not* use the indexes
     on the :operator:`$or` fields. So, the above query:

     .. code-block:: javascript

        db.inventory.find ( { $or: [ { price: 1.99 }, { sale: true } ] } ).sort({item:1})

     will not use the index on ``price`` nor the index on ``sale``.

   .. seealso:: :method:`find() <db.collection.find()>`,
      :method:`update() <db.collection.update()>`, :operator:`$set`,
      :operator:`$and`, :method:`sort() <cursor.sort()>`.
