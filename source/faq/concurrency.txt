================
FAQ: Concurrency
================

.. default-domain:: mongodb

MongoDB allows concurrent operations by using locks to ensure that
writes to a document occur without data loss. Locks ensure that all
writes occur either in full or not at all.

Locks also ensure that writes to a document or by a single connection
occur in a predetermined order.

.. contents:: Frequently Asked Questions:
   :backlinks: none
   :local:

.. _faq-concurrency-locking:

What type of locking does MongoDB use?
--------------------------------------

MongoDB uses a readers-writer lock, which allows concurrent reads
access to a database but gives exclusive access to a write.

When a read holds the lock, other reads can share it. However, when
a write holds the lock, the write holds the lock exclusively. No other
read or write can share the lock.

Locks are "writer greedy," which means writes have preference over
reads. When both a read and write are waiting for a lock, MongoDB
grants the lock to the write.

.. versionchanged:: 2.2
   Beginning with version 2.2, MongoDB implements locks on a
   per-database basis. If you have six databases and one takes a write
   lock, the other five are still available for reads. In versions prior
   to 2.2, MongoDB implements locks per :program:`mongod` instance.

For more information on locks, see the :data:`locks` documentation.

How do I view lock status?
--------------------------

To view what operations are running and what each operation has locked,
use :method:`currentOp() <db.currentOp()`>.

To view lock status, use :method:`serverStatus() <db.serverStatus()>`.
Optionally, you also can use the :doc:`mongotop </reference/mongotop>`
utility, the :doc:`mongostat </reference/mongostat>` utility, or the
`MongoDB Monitoring Service (MMS) <http://mms.10gen.com/>`_.

To terminate an operation, use :method:`killOp() <db.killOp()>`.

Does a read or write ever yield the lock?
-----------------------------------------

Yes. A read or write operation will yield MongoDB attempts to read data
that isn't yet in memory, these are called :term:`page faults
<page fault>`.

.. versionchanged:: 2.2
   MongoDB attempts to track the contents of memory and predictively
   yields locks while reading data in memory before retaking the lock to
   complete the operation

Which operations lock the database?
-----------------------------------

The following tables lists common database operations and the types of
locks they use.

.. include:: /includes/table-lock-behavior-per-operation.rst

Which administrative commands lock the database?
------------------------------------------------

Certain administrative commands can exclusively lock the database for
extended periods of time. On very large databases, consider taking the
the :program:`mongod` instance offline so that clients are not effected.
For example, if a :program:`mongod` is part of a :term:`replica set`,
take the :program:`mongod` offline and let other members of the set
service load while maintenance is in progress.

The following administrative commands can exclusively lock the database for
extended periods:

- :method:`ensureIndex() <db.collection.ensureIndex()>`, when issued
  *without* setting ``background`` to ``true``
- :dbcommand:`reIndex`
- :dbcommand:`compact`
- :method:`repair.Database() <db.repairDatabase()>`
- :method:`createCollection() <db.createCollection()>`, when creating a
  very large (many gigabytes) capped collection
- :method:`validate() <db.collection.validate()>`
- :method:`db.copyDatabase()`. This command can lock all databases. See
  :ref:`faq-concurrency-lock-multiple-dbs`.

The :method:`group() <db.collection.group()>` command takes a read lock
and does not allow any other threads to execute JavaScript while it is
running.

The following administrative commands lock the database but are fast and
do not block the system excessively:

- :method:`dropIndex() <db.collection.dropIndex()>`
- :method:`getLastError() <db.collection.getLastError()>`
- :method:`isMaster() <db.isMaster()>`
- :method:`rs.status()` and :dbcommand:`replSetGetStatus`
- :method:`serverStatus() <db.serverStatus()>`
- :method:`auth() <db.auth()>`
- :method:`addUser() <db.addUser()>`

.. _faq-concurrency-lock-multiple-dbs:

Does a MongoDB operation ever lock more than one database?
----------------------------------------------------------

MongoDB locks multiple databases in the following situations:

- :method:`db.copyDatabase()` performs a global lock.

- Journaling, which is an internal operation, locks all databases for
  short intervals. The journal is shared by all databases.

- When :ref:`authenticating <security-authentication>` a user, MongoDB
  must lock the ``admin`` database as well as the database the user is
  accessing. For more information, see
  :ref:`faq-concurrency-lock-admin`.

- When :ref:`authenticating <security-authentication>` a user, MongoDB
  must lock the ``admin`` database as well as the database the user is
  accessing.

.. _faq-concurrency-lock-admin:

Does locking the admin database cause a dead-lock?
--------------------------------------------------

.. todo Double-check this in
   http://www.10gen.com/presentations/concurrency-internals-mongodb-2-2

When :ref:`authenticating <security-authentication>` a user, MongoDB
must lock the ``admin`` database as well as the database the user is
accessing. MongoDB can do so without causing a dead-lock because the
locks are always applied in the same order.

How does sharding affect concurrency?
-------------------------------------

:term:`Sharding <sharding>` improves concurrency by spreading a database
over multiple :program:`mongod` instances. The shard cluster's
:program:`mongos` processes (i.e., each shard servers) can each perform
any number of operations concurrently to the various downstream
:program:`mongod` instances.

Each :program:`mongod` instance is independent of the others in the
cluster. The operations on one :program:`mongod` instance do not block
the operations on the others. Each :program:`mongod` instance uses the
usual MongoDB readers-writer lock (see :ref:`faq-concurrency-locking`).

.. _faq-concurrency-replication:

How does concurrency affect a replica set primary?
--------------------------------------------------

In :term:`replication`, when MongoDB writes to a collection on the
:term:`primary`, MongoDB also writes to the primary's :term:`oplog`.
Therefore, MongoDB must lock both the collection's database and the
oplog's database. The oplog is located in the ``local`` database. Both
must be locked at same time to keep the operation atomic. It's an
all-or-nothing operation.

How does concurrency affect secondaries?
----------------------------------------

In :term:`replication`, MongoDB does not apply writes serially to
:term:`secondaries <secondary>`. Secondaries collect oplog entries in
batches and then apply those batches in parallel. Secondaries do not
allow reads while applying the batch writes.

A primary might receive multiple writes at once. As writes are
happening, the order of writes is not yet established. When the primary
finishes each write, it assigns each write to a place in the oplog,
giving the writes a specific order.

The secondaries apply the writes in the order in the oplog.

MongoDB can apply several writes in parallel on replica set secondaries.
This is done in two phases:

- A prefetch phase occurs during a read lock. During this phase other
  clients may execute queries.

- A thread pool using write locks applies a batch of writes in a
  coordinated write phase.
