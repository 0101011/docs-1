=================================
Aggregation Pipeline Optimization
=================================

.. default-domain:: mongodb

.. _aggregation-optimize-performance:

Optimize Performance
--------------------

Because you will always call :dbcommand:`aggregate` on a collection
object, which logically inserts the *entire* collection into the
aggregation pipeline, you may want to optimize the operation by avoiding
scanning the entire collection whenever possible.

.. _aggregation-pipeline-operators-and-performance:

Pipeline Operators and Indexes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Depending on the order in which they appear in the pipeline,
aggregation operators can take advantage of indexes.

The following pipeline operators take advantage of an index when they
occur at the beginning of the pipeline:

- :pipeline:`$match`
- :pipeline:`$sort`
- :pipeline:`$limit`
- :pipeline:`$skip`.

The above operators can also use an index when placed **before** the
following aggregation operators:

- :pipeline:`$project`
- :pipeline:`$unwind`
- :pipeline:`$group`.

.. versionadded:: 2.4

The :pipeline:`$geoNear` pipeline operator takes advantage of a
geospatial index. When using :pipeline:`$geoNear`, the
:pipeline:`$geoNear` pipeline operation must appear as the first
stage in an aggregation pipeline.

Early Filtering
~~~~~~~~~~~~~~~

If your aggregation operation requires only a subset of the data in a
collection, use the :pipeline:`$match` operator to restrict which items go
in to the top of the pipeline, as in a query. When placed early in a
pipeline, these :pipeline:`$match` operations use suitable indexes
to scan only the matching documents in a collection.

Placing a :pipeline:`$match` pipeline stage followed by a
:pipeline:`$sort` stage at the
start of the pipeline is logically equivalent to a single query
with a sort, and can use an index.

.. OMMITED: this feature is pending SERVER-4506. Other optimizations
.. are pending SERVER-4507 SERVER-4644 SERVER-4656 SERVER-4816
..
.. :term:`Aggregation` operations have an optimization phase, before
.. execution, which attempts to re-arrange the pipeline by moving
.. :pipeline:`$match` operators towards the beginning to the
.. greatest extent possible. For example, if a pipeline begins
.. with a :pipeline:`$project` that renames fields, followed by a
.. :pipeline:`$match`, the optimizer can improve performance
.. without affecting the result by moving the :pipeline:`$match`
.. operator in front of the :pipeline:`$project`.

In future versions there may be an optimization phase in the
pipeline that reorders the operations to increase performance without
affecting the result. However, at this time place
:pipeline:`$match` operators at the beginning of the pipeline when
possible.

Pipeline Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionchanged:: 2.4

Aggregation operations have an optimization phase which attempts to
re-arrange the pipeline for improved performance.

``$sort`` + ``$skip`` + ``$limit`` Sequence Optimization
````````````````````````````````````````````````````````

When you have sequence of :pipeline:`$sort` followed by a
:pipeline:`$skip` followed by a :pipeline:`$limit`, an
optimization occurs whereby the :pipeline:`$limit` moves in front
of the :pipeline:`$skip`. For example, if the pipeline consists of
the following stages:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $skip: 10 },
   { $limit: 5 }

During the optimization phase, the optimizer transforms the sequence to
the following:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $limit: 15 }
   { $skip: 10 }

.. note::

   The :pipeline:`$limit` value has increased to the sum of the
   initial value and the :pipeline:`$skip` value.

``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` Sequence Optimization
`````````````````````````````````````````````````````````````````````

When you have a continuous sequence of a :pipeline:`$limit` pipeline
stage followed by a :pipeline:`$skip` pipeline stage, the
aggregation will attempt to re-arrange the pipeline stages to combine
the limits together and the skips together. For example, if the
pipeline consists of the following stages:

.. code-block:: javascript

   { $limit: 100 },
   { $skip: 5 },
   { $limit: 10},
   { $skip: 2 }

During the intermediate step, the optimizer reverses the position of
the :pipeline:`$skip` followed by a :pipeline:`$limit` to
:pipeline:`$limit` followed by the :pipeline:`$skip`.

.. code-block:: javascript

   { $limit: 100 },
   { $limit: 15},
   { $skip: 5 },
   { $skip: 2 }

The :pipeline:`$limit` value has increased to the sum of the
initial value and the :pipeline:`$skip` value. Then, for the final
:pipeline:`$limit` value, the optimizer selects the minimum between
the adjacent :pipeline:`$limit` values. For the final
:pipeline:`$skip` value, the optimizer adds the adjacent
:pipeline:`$skip` values, to transform the sequence to the
following:

.. code-block:: javascript

   { $limit: 15 },
   { $skip: 7 }

Memory for Cumulative Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Certain pipeline operators require access to the entire input set before
they can produce any output. For example, :pipeline:`$sort` must receive
all of the input from the preceding :ref:`pipeline <aggregation-pipeline>`
operator before it can produce its first output document. The current
implementation of :pipeline:`$sort` does not go to disk in these cases:
in order to sort the contents of the pipeline, the entire input must fit
in memory.

.. include:: /includes/fact-agg-sort-limit.rst

:pipeline:`$group` has similar characteristics: Before any
:pipeline:`$group` passes its output along the pipeline, it must
receive the entirety of its input. For the :pipeline:`$group`
operator, this frequently does not require as much memory as
:pipeline:`$sort`, because it only needs to retain one record for
each unique key in the grouping specification.

The current implementation of the aggregation pipeline logs a warning
if a cumulative operator consumes 5% or more of the physical memory on
the host. Cumulative operators produce an error if they consume 10% or
more of the physical memory on the host.
