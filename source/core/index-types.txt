.. index:: index types
.. _index-types:

===========
Index Types
===========

.. default-domain:: mongodb

MongoDB provides a number of different index types. You can create
indexes on any field or embedded field within a document or
sub-document. You can create compound indexes with multiple fields so
that a single query can match multiple components using the index
while scanning fewer whole documents.

In general, you should create indexes that support your primary, common,
and user-facing queries. Having these indexes will ensure that MongoDB
only scans the smallest possible number of documents.

In the :program:`mongo` shell, you can create an index by calling the
:method:`ensureIndex() <db.collection.ensureIndex()>` method. on any
single field or :ref:`sequence of fields <index-type-compound>` within
any document or :ref:`sub-document <index-sub-document>`. MongoDB also
supports indexes of arrays, called :ref:`multi-key indexes
<index-type-multi-key>`. For more
detailed instructions about building indexes, see the :doc:`Indexing
Tutorials </administration/indexes>` page.

Behavior of Index Types
-----------------------

All indexes in MongoDB are :term:`B-tree` indexes, which can
efficiently support equality matches and range queries. The index
stores items internally in order sorted by the value of the index
field. The ordering of index entries supports efficient range-based
operations and allows MongoDB to return sorted results using the order
of documents in the index.

Ordering of Indexes
~~~~~~~~~~~~~~~~~~~

For the ordering of an index, MongoDB can use *either* ascending
(e.g. ``1``) or descending (e.g. ``-1``) order. However, MongoDB may
also transverse the index in both directions. As a result, for
single-field indexes, ascending and descending indexes are
interchangeable. For compound indexes the direction of the ordering
for index can have a greater impact on the results.

See :ref:`index-ascending-and-descending` for more information on the
impact of index order on results in compound indexes.

Prefixes
~~~~~~~~

Compound indexes support queries on any prefix of the fields in the
index. [#prefix]_

If you have a collection that has a compound index on ``{ a: 1, b: 1
}`` and a single field index on ``{ a: 1 }``, assuming there neither
index has a sparse or unique constraints on the index, the
single-field index is *a prefix* of the compound index and may be
redundant for most uses. MongoDB will be able to use the compound
index in all of situations that it would have used the single field
index.

.. example::

   Given the following index:

   .. code-block:: javascript

      { "item": 1, "location": 1, "stock": 1 }

   MongoDB **can** use this index to support queries that include:

   - the ``item`` field, and
   - the ``item`` field *and* the ``location`` field.

   MongoDB **cannot** use this index to support queries that include:

   - only the ``location`` field,
   - only the ``stock`` field,
   - only the ``location`` *and* ``stock`` fields, and
   - only the ``item`` *and* ``stock`` fields.

.. [#prefix] Index prefixes are the beginning subset of fields. For
   example, given the index ``{ a: 1, b: 1, c: 1 }`` both ``{ a: 1 }``
   and ``{ a: 1, b: 1 }`` are prefixes of the index.

Redundant Indexes
~~~~~~~~~~~~~~~~~

A single query can only use *one* index, except for queries that use
the :operator:`$or` operator that can use a different index for each
clause.

.. seealso:: :ref:`Index Limitations <index-limitations>`.

Index Type Documentation
------------------------

.. include:: /includes/dfn-list-indexes-concepts-types.rst

.. include:: /includes/toc-indexes-concepts-types.rst
