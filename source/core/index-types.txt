.. index:: index types
.. _index-types:

===========
Index Types
===========

.. default-domain:: mongodb

MongoDB provides a number of different index types. You can create
indexes on any field or embedded field within a document or
sub-document. You can create compound indexes with multiple fields so
that a single query can match multiple components using the index
while scanning fewer whole documents.

In general, you should create indexes that support your common and
user-facing queries. Having these indexes will ensure that MongoDB
scans the smallest possible number of documents.

In the :program:`mongo` shell, you can create an index by calling the
:method:`ensureIndex() <db.collection.ensureIndex()>` method with a
single field or :ref:`sequence of fields <index-type-compound>`.
MongoDB also supports indexes of arrays, called :ref:`multi-key indexes
<index-type-multi-key>`. For more detailed instructions about building
indexes, see the :doc:`Indexing Tutorials </administration/indexes>`
page.

Behavior of Index Types
-----------------------

All indexes in MongoDB are :term:`B-tree` indexes, which can
efficiently support equality matches and range queries. The index
stores items internally in order sorted by the value of the index
field. The ordering of index entries supports efficient range-based
operations and allows MongoDB to return sorted results using the order
of documents in the index.

Ordering of Indexes
~~~~~~~~~~~~~~~~~~~

MongoDB indexes may be ascending, (i.e. ``1``) or descending
(i.e. ``-1``) in their ordering. Nevertheless, MongoDB may also
traverse the index in either directions. As a result, for
single-field indexes, ascending and descending indexes are
interchangeable. This is not the case for compound indexes: in
compound indexes, the direction of the sort order can have a
greater impact on the results.

See :ref:`index-ascending-and-descending` for more information on the
impact of index order on results in compound indexes.

Prefixes
~~~~~~~~

Indexes on multiple fields, or :ref:`compound indexes
<index-type-compound>`, support queries on any prefix of the index
fields. Index prefixes are the beginning subset of indexed fields. For
example, given the index ``{ a: 1, b: 1, c: 1 }``, both ``{ a: 1 }``
and ``{ a: 1, b: 1 }`` are prefixes of the index.

If you have a collection that has a compound index on ``{ a: 1, b:
1}``, as well as an index that consists of the prefix of that index,
i.e. ``{ a: 1 }``, assuming none of the index has a sparse or unique
constraints, then you can drop the ``{ a: 1 }`` index. MongoDB will be
able to use the compound index in all of situations that it would have
used either the ``{ a: 1 }`` index.

.. example::

   Given the following index:

   .. code-block:: javascript

      { "item": 1, "location": 1, "stock": 1 }

   MongoDB **can** use this index to support queries that include:

   - the ``item`` field, and
   - the ``item`` field *and* the ``location`` field, and
   - the ``item`` field *and* the ``location`` field *and* the ``stock`` field.

   MongoDB **cannot** use this index to support queries that include:

   - only the ``location`` field,
   - only the ``stock`` field,
   - only the ``location`` *and* ``stock`` fields, and
   - only the ``item`` *and* ``stock`` fields.

Redundant Indexes
~~~~~~~~~~~~~~~~~

A single query can only use *one* index, except for queries that use
the :operator:`$or` operator that can use a different index for each
clause.

.. seealso:: :ref:`Index Limitations <index-limitations>`.

Index Type Documentation
------------------------

.. include:: /includes/dfn-list-indexes-concepts-types.rst

.. include:: /includes/toc-indexes-concepts-types.rst
