=================================
Aggregation Pipeline Optimization
=================================

.. default-domain:: mongodb

.. _aggregation-optimize-performance:

In MongoDB, the :dbcommand:`aggregate` operate on a single collection,
logically passing the *entire* collection into the aggregation
pipeline. Whenever possible, avoid scanning the entire collection to
optimize the operation.

.. _aggregation-pipeline-operators-and-performance:

Pipeline Operators and Indexes
------------------------------

Depending on the order in which they appear in the pipeline,
aggregation operators can take advantage of indexes.

The following pipeline operators take advantage of an index when they
occur at the beginning of the pipeline:

- :pipeline:`$match`
- :pipeline:`$sort`
- :pipeline:`$limit`
- :pipeline:`$skip`.

The above operators can also use an index when placed **before** the
following aggregation operators:

- :pipeline:`$project`
- :pipeline:`$unwind`
- :pipeline:`$group`.

.. versionadded:: 2.4

The :pipeline:`$geoNear` pipeline operator takes advantage of a
geospatial index. When using :pipeline:`$geoNear`, the
:pipeline:`$geoNear` pipeline operation must appear as the first
stage in an aggregation pipeline.

Early Filtering
---------------

If your aggregation operation requires only a subset of the data in a
collection, use the :pipeline:`$match` operator to restrict which items go
in to the top of the pipeline, as in a query. When placed early in a
pipeline, these :pipeline:`$match` operations use suitable indexes
to scan only the matching documents in a collection.

Placing a :pipeline:`$match` pipeline stage followed by a
:pipeline:`$sort` stage at the start of the pipeline is logically
equivalent to a single query with a sort and can use an index. When
possible, place :pipeline:`$match` operators at the beginning of the
pipeline.

.. OMMITED: this feature is pending SERVER-4506. Other optimizations
.. are pending SERVER-4507 SERVER-4644 SERVER-4656 SERVER-4816
..
.. :term:`Aggregation` operations have an optimization phase, before
.. execution, which attempts to re-arrange the pipeline by moving
.. :pipeline:`$match` operators towards the beginning to the
.. greatest extent possible. For example, if a pipeline begins
.. with a :pipeline:`$project` that renames fields, followed by a
.. :pipeline:`$match`, the optimizer can improve performance
.. without affecting the result by moving the :pipeline:`$match`
.. operator in front of the :pipeline:`$project`.

.. _aggregation-pipeline-sequence-optimization:

Pipeline Sequence Optimization
------------------------------

.. versionchanged:: 2.4

Aggregation pipeline operations have an optimization phase which
attempts to re-arrange the pipeline for improved performance.

``$sort`` + ``$skip`` + ``$limit`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you have sequence of :pipeline:`$sort` followed by a
:pipeline:`$skip` followed by a :pipeline:`$limit`, an
optimization occurs whereby the :pipeline:`$limit` moves in front
of the :pipeline:`$skip`. For example, if the pipeline consists of
the following stages:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $skip: 10 },
   { $limit: 5 }

During the optimization phase, the optimizer transforms the sequence to
the following:

.. code-block:: javascript

   { $sort: { age : -1 } },
   { $limit: 15 }
   { $skip: 10 }

.. note::

   The :pipeline:`$limit` value has increased to the sum of the
   initial value and the :pipeline:`$skip` value.

``$limit`` + ``$skip`` + ``$limit`` + ``$skip`` Sequence Optimization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you have a continuous sequence of a :pipeline:`$limit` pipeline
stage followed by a :pipeline:`$skip` pipeline stage, the
aggregation will attempt to re-arrange the pipeline stages to combine
the limits together and the skips together. For example, if the
pipeline consists of the following stages:

.. code-block:: javascript

   { $limit: 100 },
   { $skip: 5 },
   { $limit: 10},
   { $skip: 2 }

During the intermediate step, the optimizer reverses the position of
the :pipeline:`$skip` followed by a :pipeline:`$limit` to
:pipeline:`$limit` followed by the :pipeline:`$skip`.

.. code-block:: javascript

   { $limit: 100 },
   { $limit: 15},
   { $skip: 5 },
   { $skip: 2 }

The :pipeline:`$limit` value has increased to the sum of the
initial value and the :pipeline:`$skip` value. Then, for the final
:pipeline:`$limit` value, the optimizer selects the minimum between
the adjacent :pipeline:`$limit` values. For the final
:pipeline:`$skip` value, the optimizer adds the adjacent
:pipeline:`$skip` values, to transform the sequence to the
following:

.. code-block:: javascript

   { $limit: 15 },
   { $skip: 7 }
