2.. index:: write operations
.. index:: crud; write operations

================
Write Operations
================

.. default-domain:: mongodb

All operations that create or modify data in the MongoDB instance are
write operations. MongoDB represents data as :term:`BSON documents
<document>` stored in :term:`collections <collection>`. Write
operations target one collection and are atomic on the level of a
single document: no single write operation can atomically affect more
than one document or more than one collection.

.. include:: /includes/dfn-list-crud-write-operations.rst

.. include:: /includes/toc-crud-write-operations.rst

Write Operations in MongoDB
---------------------------

.. _write-operations-isolation:

Isolation
~~~~~~~~~

When a single write operation modifies multiple documents, the
operation as a whole is not atomic, and other operations may
interleave. The modification of a single document, or record, is always
atomic, even if the write operation modifies multiple sub-document
*within* the single record.

No other operations are atomic; however, you can attempt to isolate a
write operation that affects multiple documents using the
:doc:`isolation operator </reference/operator/isolated>`.

To isolate a sequence of write operations from other read and write
operations, see :doc:`/tutorial/perform-two-phase-commits`.

.. _write-operations-indexing:

Impact on Indexes
~~~~~~~~~~~~~~~~~

After every insert, update, or delete operation, MongoDB must update
*every* index associated with the collection in addition to the data
itself. Therefore, every index on a collection adds some amount of
overhead for the performance of write operations. [#exceptions]_

In general, the performance gains that indexes provide for *read
operations* are worth the insertion penalty; however, when optimizing
write performance, be careful when creating new indexes and always
evaluate the indexes on the collection and ensure that your queries are
actually using these indexes.

For more information on indexes in MongoDB, see :doc:`/indexes` and
:doc:`/applications/indexes`.

.. [#exceptions] The overhead for :ref:`sparse indexes <index-type-sparse>`
   inserts and updates to un-indexed fields is less than for non-sparse
   indexes. Also for non-sparse indexes, updates that don't change the
   record size have less indexing overhead.
