.. _read-operations-indexing:

=======================================
Read Operation Performance Optimization
=======================================

.. default-domain:: mongodb

Indexes improve the efficiency of read operations by reducing the
amount of data that query operations need to process. This simplifies
the work associated with fulfilling queries within MongoDB.

Create an Index to Support Read Operations
------------------------------------------

If your application queries a collection on a particular field or
fields, then an index on the field or fields can improve the
performance of the read operations.

.. example:: An application queries the ``inventory`` collection on the
   ``type`` field. The value of the ``type`` field is user-driven.

   .. code-block:: javascript

      var typeValue = <someUserInput>;
      db.inventory.find( { type: typeValue } );

   To improve the performance of this query, add an ascending, or a
   descending, index to the ``inventory`` collection on the ``type``
   field. [#ensureIndexOrder]_ In the :program:`mongo` shell, you can
   create indexes using the :method:`db.collection.ensureIndex()`
   method:

   .. code-block:: javascript

      db.inventory.ensureIndex( { type: 1 } )

For more information on creating indexes, see :doc:`/core/indexes` and
:method:`db.collection.ensureIndex()`.

.. [#ensureIndexOrder]
   For single-field indexes, the selection between ascending and
   descending order is immaterial. For compound indexes, the selection
   is important. See :ref:`indexing order
   <index-ascending-and-descending>` for more details.

Analyze Query Plan
------------------

The :method:`~cursor.explain()` cursor method allows you to inspect the
operation of the query system. This method is useful for analyzing the
efficiency of queries, and for determining how the query uses the
index. The :method:`~cursor.explain()` method tests the query
operation, and *not* the timing of query performance. Because
:method:`~cursor.explain()` attempts multiple query plans, it does not
reflect an accurate timing of query performance.

To use the :method:`~cursor.explain()` method, call the method on a
cursor returned by :method:`~db.collection.find()`.

.. example:: Evaluate a query on the ``type`` field on the collection
   ``inventory`` that has an index on the ``type`` field.

   .. code-block:: javascript

      db.inventory.find( { type: 'food' } ).explain()

   Consider the results:

   .. code-block:: javascript

      {
        "cursor" : "BtreeCursor type_1",
        "isMultiKey" : false,
        "n" : 5,
        "nscannedObjects" : 5,
        "nscanned" : 5,
        "nscannedObjectsAllPlans" : 5,
        "nscannedAllPlans" : 5,
        "scanAndOrder" : false,
        "indexOnly" : false,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "millis" : 0,
        "indexBounds" : { "type" : [
                                      [ "food",
                                        "food" ]
                                   ] },
        "server" : "mongodbo0.example.net:27017" }

   The ``BtreeCursor`` value of the :data:`~explain.cursor` field
   indicates that the query used an index. This query returned 5
   documents, as indicated by the :data:`~explain.n` field. To return
   these 5 documents, the query scanned 5 documents from the index, as
   indicated by the :data:`~explain.nscanned` field, and then read 5
   full documents from the collection, as indicated by the
   :data:`~explain.nscannedObjects` field.

   Without the index, the query would have scanned the whole collection
   to return the 5 documents.

To manually compare the performance of a query using more than one
index, you can use the :method:`~cursor.hint()` and
:method:`~cursor.explain()` methods in conjunction

.. example:: Evaluate a query using different indexes:

   .. code-block:: javascript

      db.inventory.find( { type: 'food' } ).hint( { type: 1 } ).explain()
      db.inventory.find( { type: 'food' } ).hint( { type: 1, name: 1 } ).explain()

   These return the statistics regarding the execution of the query
   using the respective index.

For more information on the explain output, see
:method:`~cursor.explain()`.

.. _read-operations-covered-query:

Covering a Query
----------------

An index :ref:`covers <indexes-covered-queries>` a query, a *covered
query*, when:

- all the fields in the :ref:`query <read-operations-query-document>`
  are part of that index, **and**

- all the fields returned in the documents that match the query are in
  the same index.

For these queries, MongoDB does not need to inspect documents outside
of the index. This is often more efficient than inspecting entire
documents.

.. example::

   Given a collection ``inventory`` with the following index on the
   ``type`` and ``item`` fields:

   .. code-block:: sh

      { type: 1, item: 1 }

   This index will cover the following query on the ``type`` and ``item``
   fields, which returns only the ``item`` field:

   .. code-block:: javascript

      db.inventory.find( { type: "food", item:/^c/ },
                         { item: 1, _id: 0 } )

   However, this index will **not** cover the following query, which
   returns the ``item`` field **and** the ``_id`` field:

   .. code-block:: javascript

      db.inventory.find( { type: "food", item:/^c/ },
                         { item: 1 } )

See :ref:`indexes-covered-queries` for more information on the
behavior and use of covered queries.

Query Operations that Cannot Use Indexes Effectively
----------------------------------------------------

Some query operations cannot use indexes effectively or cannot use
indexes at all.

The inequality operators :operator:`$nin` and :operator:`$ne` are not
very selective, as they often match a large portion of the index. As a
result, in most cases, a :operator:`$nin` or :operator:`$ne` query with
an index may perform no better than a :operator:`$nin` or
:operator:`$ne` query that must scan all documents in a collection.

Queries that specify regular expressions, with inline JavaScript
regular expressions or :operator:`$regex` operator expressions, cannot
use an index with one exception. Queries that specify regular
expression *with anchors* at the beginning of a string *can* use an
index.

Further Reading
---------------

In addition to optimizing read operations, indexes can support sort
operations and allow for a more efficient storage utilization. For a
detailed look into indexes in MongoDB, including additional information
on how indexes support read operations, see :doc:`/core/indexes`.
