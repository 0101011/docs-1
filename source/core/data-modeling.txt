=============
Data Modeling
=============

.. default-domain:: mongodb

Overview
--------

In MongoDB, the schema design takes into consideration both the data to
be modeled *and* the use cases. Schema design determines the structure
of the documents, the number and types of collections, indexing and
sharding.

.. _data-modeling-decisions:

Data Modeling Decisions
-----------------------

Data modeling decisions involve determining how to structure the
documents to effectively model the data. The primary decision is
whether to :ref:`embed <data-modeling-embedding>` or to :ref:`link
<data-modeling-linking>` related data.

.. _data-modeling-embedding:

Embedding
~~~~~~~~~

Embedding, or de-normalization of data, is a bit like "prejoined" data.
Operations within a document are easy for the server to handle.
Embedding allows for large sequential reads.

Embedding is frequently the choice for:

- "contains" relationships between entities. See
  :ref:`data-modeling-example-one-to-one`.

- one-to-many relationships when the "many" objects always appear with
  or are viewed in the context of their parents. See
  :ref:`data-modeling-example-many-addresses`.

Embedding provides the following benefits:

- Great for read performance

- Single roundtrip to database to retrieve the complete object

However, embedding presents some considerations:

- Writes can be slow if adding to objects frequently.

- You cannot embed documents that will cause the containing document to
  exceed the :limit:`maximum BSON document size <BSON Document Size>`.
  For documents that exceed the maximum BSON document size, see
  :doc:`/applications/gridfs`.
  
- You cannot have nested embedded levels more than the specified
  :limit:`limit on embedded levels <Nested Depth for BSON Documents>`.

For examples in accessing embedded documents, see
:ref:`read-operations-subdocuments`.

.. _data-modeling-linking:

Linking
~~~~~~~

Linking, or normalization of data, joins separate documents using
:doc:`references </applications/database-references>` or links. Links
are processed client-side by the application; the application does this
by issuing a follow-up query. Linking involves performing many seeks
and random reads.

Linking is frequently the choice for:

- embedding would result in duplication of data. 

- many-to-many relationships. 

See :ref:`data-modeling-publisher-and-books` for example of linking.

Linking provides more flexibility than embedding; however, linking
requires client-side processing to resolve the link by issuing
follow-up queries to retrieve the entire object.

.. _data-modeling-atomicity:

Atomicity
~~~~~~~~~

Atomicity influences the decision to embed or link. The modification of
a single document is atomic, even if the write operation modifies
multiple sub-documents *within* the single document.

Embed fields relevant to the atomic operation in the same document.

Operational Considerations
--------------------------

Operational considerations involve the data lifecycle managements,
determining the number of collections, 

Data Lifecycle Management
~~~~~~~~~~~~~~~~~~~~~~~~~

Data lifecycle management determines the type of collection or
collection feature to implement in your schema design.

Some data may only need to persist in a database for a limited period
of time. In these cases, you should consider using the :doc:`Time to
Live or TTL feature</tutorial/expire-data/>` of collections.

Additionally, if you will be only concerned with the most recent
documents, you should consider :doc:`/core/capped-collections`. Capped
collections provide *first-in-first-out* management of inserted
documents and support high-throughput operations that insert, read,
and delete documents based on insertion order.

Large Number of Collections
~~~~~~~~~~~~~~~~~~~~~~~~~~~

In certain situation, you might choose to store information in several
collections instead of a single collection. 

Consider a sample collection ``logs`` that stores log documents for
various environment and applications. The ``logs`` collection contains
documents of the following form:

.. code-block:: javascript

   { log: "dev", ts: ..., info: ... }
   { log: "debug", ts: ..., info: ...}
     
If the number of different logs is not too high, you may decide to have
separate log collections, such as ``logs.dev`` and ``logs.debug``. The
``logs.dev`` collection would contain only the log documents related to
the dev environment.

Generally, having large number of collections has no significant
performance penalty and results in very good performance. Independent
collections are very important for high-throughput batch processing.

When creating large numbers of collections, consider the following
items:

- Each collection has a certain minimum overhead of a few kilobytes per
  collection.

- Each index requires at least 8KB of data space as the B-tree page
  size is 8KB.

- :limit:`Limits on the number of namespaces <Number of Namespaces>`
  exist:

  - Each index, as well as each collection, counts as a namespace.

  - Each namespace is 628 bytes.

  - Namespaces are stored per database in a ``<database>.ns`` file:

    - The ``<database>.ns`` file defaults to 16 MB.

    - To change the size of the ``<database>.ns`` file, use
      :option:`--nssize \<new size MB\> <mongod --nssize>` on server
      startup.

      .. note:: 

         - The maximum size of the ``<database>.ns`` file is 2047 MB.

         - :option:`--nssize <mongod --nssize>` sets the size used for
           *new* ``<database>.ns`` files. For existing databases, after
           starting up the server with :option:`--nssize <mongod
           --nssize>`, run the :dbcommand:`db.repairDatabase()` command
           from the :program:`mongo` shell.

You can check the namespaces by querying the ``system.namespaces``
collection, as in the following example:

.. code-block:: javascript

   db.system.namespaces.count()

Indexes
~~~~~~~

As a general rule, where you want an index in a relational database,
you want an index in Mongo. Indexes in MongoDB are needed for efficient
query processing, as such, you may want to think about the queries
first and then build indexes based upon them. Generally, you would
index the fields that you query by and the fields that you sort by.

As you create indexes, consider the following aspects of indexes:

- Each index requires at least 8KB of data space as the B-tree page
  size is 8KB.

- The ``_id`` field is automatically indexed.
  
- Adding an index slows write operations but not read operations:

  - This allows for for collections with high read-to-write ratio to
    have lots of indexes.

  - For collections with high write-to-read ratio, indexes are
    expensive as each insert must add keys to each index.

See :doc:`/applications/indexes` for more information on determining
indexes. Additionally, MongoDB :wiki:`Database Profiler` provides
information for determining if an index is needed.

Sharding
~~~~~~~~

MongoDB's sharding system allows users to :term:`partition` a
:term:`collection` within a database to distribute the collection's
documents across a number of :program:`mongod` instances or
:term:`shards <shard>`. A BSON document (which may have significant
amounts of embedding) resides on one and only one shard.

Sharding provides the following benefits:

- increases write capacity,

- provides the ability to support larger working sets, and

- raises the limits of total data size beyond the physical resources of
  a single node.

When a collection is sharded, the shard key determines how the
collection is partitioned among shards. Typically (but not always)
queries on a sharded collection involve the shard key as part of the
query expression.

See :doc:`/core/sharding` for more information on sharding.

Document Growth
~~~~~~~~~~~~~~~

Document growth forces MongoDB to move the document on disk, which can
be time and resource consuming relative to other operations.

See :doc:`/use-cases/pre-aggregated-reports/` for some approaches to
handling document growth.

Patterns and Examples
---------------------

.. _data-modeling-example-one-to-one:

One-to-one: Patron and Address
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the following linking example that has two data objects, ``patron``
and the corresponding ``address`` information, that have a one-to-one
relationship.

.. code-block:: javascript

   patron = {
              _id: "joe",
              name: "Joe Bookreader"
            }

   address = {
               patron_id: "joe",
               street: "123 Fake Street",
               city: "Faketon",
               state: "MA"
               zip: 12345
             }

Because ``address`` is owned by the ``patron``, this one-to-one
relationship may be better modeled by embedding the ``address``
document in the ``patron`` document, as in the following document:

.. code-block:: javascript

   patron = {
      _id: "joe",
      name: "Joe Bookreader",
      address: {
                 street: "123 Fake Street",
                 city: "Faketon",
                 state: "MA"
                 zip: 12345
               }
   }

.. _data-modeling-example-one-to-many:

One-to-Many
~~~~~~~~~~~

.. _data-modeling-example-many-addresses:

Patron with Many Addresses
``````````````````````````

Consider the following embedding example that has three data objects,
``patron`` and two separate ``address`` information, that have a
one-to-many relationship:

.. code-block:: javascript

   patron = {
              _id: "joe",
              name: "Joe Bookreader"
            }

   address1 = {
               patron_id = "joe",
               street: "123 Fake Street",
               city: "Faketon",
               state: "MA",
               zip: 12345
             }

   address2 = {
               patron_id: "joe",
               street: "1 Some Other Street",
               city: "Boston",
               state: "MA",
               zip: 12345
             }

This one-to-many relationship may be modeled by embedding the
``address`` documents in the ``patron`` document, as in the following
document:

.. code-block:: javascript

   patron = {
               _id: "joe",
               name: "Joe Bookreader",
               addresses: [
                            {
                              street: "123 Fake Street",
                              city: "Faketon",
                              state: "MA",
                              zip: 12345
                            },
                            {
                              street: "1 Some Other Street",
                              city: "Boston",
                              state: "MA",
                              zip: 12345
                            }
                          ]
            }

.. _data-modeling-publisher-and-books:

Modeling Publishers and Books
`````````````````````````````

Consider the following example that models the one-to-many
relationship between publishers and books. 

.. code-block:: javascript

   publisher = {
                 name: "O'Reilly Media",
                 founded: 1980,
                 location: "CA"
               }

   book1 = {
             title: "MongoDB: The Definitive Guide",
             author: [ "Kristina Chodorow", "Mike Dirolf" ],
             published_date: ISODate("2010-09-24"),
             pages: 216,
             language: "English"
           }

   book2 = {
             title: "50 Tips and Tricks for MongoDB Developer",
             author: "Kristina Chodorow",
             published_date: ISODate("2011-05-06"),
             pages: 68,
             language: "English"
           }

Embedding the publisher document inside the book document would lead to
**repetition** of the publisher data in the books published by the
particular publisher, as the following documents show:

.. code-block:: javascript
   :emphasize-lines: 7-11,20-24

   book1 = {
             title: "MongoDB: The Definitive Guide",
             author: [ "Kristina Chodorow", "Mike Dirolf" ],
             published_date: ISODate("2010-09-24"),
             pages: 216,
             language: "English",
             publisher: {
                          name: "O'Reilly Media",
                          founded: 1980,
                          location: "CA"
                        }
           }

   book2 = {
             title: "50 Tips and Tricks for MongoDB Developer",
             author: "Kristina Chodorow",
             published_date: ISODate("2011-05-06"),
             pages: 68,
             language: "English",
             publisher: {
                          name: "O'Reilly Media",
                          founded: 1980,
                          location: "CA"
                        }
           }

To avoid repetition of the publisher data, use *linking* and keep the
publisher information in a separate collection from the book
collection. 

When linking the one-to-many relationship, the size and growth of the
relationships determine where to store the reference. If the number
of books per publisher is small with limited growth, storing the book
reference inside the publisher document may be useful; otherwise, if
the number of books per publisher is unbounded, this data model would
lead to mutable, growing arrays, as in the following example:

.. code-block:: javascript
   :emphasize-lines: 5
   
   publisher = {
                 name: "O'Reilly Media",
                 founded: 1980,
                 location: "CA",
                 books: [12346789, 234567890, ...]
               }

   book1 = {
             _id: 123456789,
             title: "MongoDB: The Definitive Guide",
             author: [ "Kristina Chodorow", "Mike Dirolf" ],
             published_date: ISODate("2010-09-24"),
             pages: 216,
             language: "English"
           }

   book2 = {
             _id: 234567890,
             title: "50 Tips and Tricks for MongoDB Developer",
             author: "Kristina Chodorow",
             published_date: ISODate("2011-05-06"),
             pages: 68,
             language: "English"
           }

Because the number of books per publisher may continue to grow,
embedding the publisher reference inside the book document is preferred:

.. code-block:: javascript
   :emphasize-lines: 15, 25
   
   publisher = {
                 _id: "oreilly",
                 name: "O'Reilly Media",
                 founded: 1980,
                 location: "CA",
               }

   book1 = {
             _id: 123456789,
             title: "MongoDB: The Definitive Guide",
             author: [ "Kristina Chodorow", "Mike Dirolf" ],
             published_date: ISODate("2010-09-24"),
             pages: 216,
             language: "English",
             publisher_id: "oreilly"
           }

   book2 = {
             _id: 234567890,
             title: "50 Tips and Tricks for MongoDB Developer",
             author: "Kristina Chodorow",
             published_date: ISODate("2011-05-06"),
             pages: 68,
             language: "English",
             publisher_id: "oreilly"
           }

.. _data-modeling-trees:

Trees
~~~~~

MongoDB provides various patterns to store *Trees* or hierarchical data.

Parent Links
````````````

The *Parent Links* pattern stores each tree node in a document; in
addition to the tree node, the document stores the id of the node's
parent.

Consider the following example that models a tree of categories using
*Parent Links*:

.. code-block:: javascript

   db.categories.insert( { _id: "MongoDB", parent: "Databases" } )
   db.categories.insert( { _id: "Postgres", parent: "Databases" } )
   db.categories.insert( { _id: "Databases", parent: "Programming" } )
   db.categories.insert( { _id: "Languages", parent: "Programming" } )
   db.categories.insert( { _id: "Programming", parent: "Books" } )
   db.categories.insert( { _id: "Books", parent: null } )

- The query to retrieve the parent of a node is fast and
  straightforward:

  .. code-block:: javascript

     db.categories.findOne( { _id: "MongoDB" } ).parent

- You can create an index on the field ``parent`` to enable fast search
  by the parent node:

  .. code-block:: javascript

     db.categories.ensureIndex( { parent: 1 } )

- You can query by the ``parent`` field to find its immediate children
  nodes:

  .. code-block:: javascript

     db.categories.find( { parent: "Databases" } )
   
The *Parent Links* pattern provides a simple solution to tree storage,
but requires successive queries to the database to retrieve subtrees.

Child Links
```````````

The *Child Links* pattern stores each tree node in a document; in
addition to the tree node, document stores in an array the id(s) of the
node's children.

Consider the following example that models a tree of categories using
*Child Links*:

.. code-block:: javascript

   db.categories.insert( { _id: "MongoDB", children: [] } )
   db.categories.insert( { _id: "Postgres", children: [] } )
   db.categories.insert( { _id: "Databases", children: [ "MongoDB", "Postgres" ] } )
   db.categories.insert( { _id: "Languages", children: [] } )
   db.categories.insert( { _id: "Programming", children: [ "Databases", "Languages" ] } )
   db.categories.insert( { _id: "Books", children: [ "Programming" ] } )

- The query to retrieve the immediate children of a node is fast and
  straightforward:

  .. code-block:: javascript

     db.categories.findOne( { _id: "Databases" } ).children

- You can create an index on the field ``children`` to enable fast
  search by the child nodes:

  .. code-block:: javascript

     db.categories.ensureIndex( { children: 1 } )

- You can query for a node in the ``children`` field to find its parent
  node as well as its siblings:

  .. code-block:: javascript

     db.categories.find( { children: "MongoDB" } )
     
The *Child Links* pattern provides a suitable solution to tree storage
as long as no operations on subtrees are necessary. This pattern may
also provide a suitable solution for storing graphs where a node may
have multiple parents.

Array of Ancestors
``````````````````

The *Array of Ancestors* pattern stores each tree node in a document;
in addition to the tree node, document stores in an array the id(s) of
the node's ancestors or path.

Consider the following example that models a tree of categories using
*Array of Ancestors*:

.. code-block:: javascript

   db.categories.insert( { _id: "MongoDB", ancestors: [ "Books", "Programming", "Databases" ], parent: "Databases" } )
   db.categories.insert( { _id: "Postgres", ancestors: [ "Books", "Programming", "Databases" ], parent: "Databases" } )
   db.categories.insert( { _id: "Databases", ancestors: [ "Books", "Programming" ], parent: "Programming" } )
   db.categories.insert( { _id: "Languages", ancestors: [ "Books", "Programming" ], parent: "Programming" } )
   db.categories.insert( { _id: "Programming", ancestors: [ "Books" ], parent: "Books" } )
   db.categories.insert( { _id: "Books", ancestors: [ ], parent: null } )

- The query to retrieve the ancestors or path of a node is fast and
  straightforward:

  .. code-block:: javascript

     db.categories.findOne( { _id: "MongoDB" } ).ancestors

- You can create an index on the field ``ancestors`` to enable fast
  search by the ancestors nodes:

  .. code-block:: javascript

     db.categories.ensureIndex( { ancestors: 1 } )

- You can query by the ``ancestors`` to find all its descendants:

  .. code-block:: javascript

     db.categories.find( { ancestors: "Programming" } )

The *Array of Ancestors* pattern provides a fast and efficient solution
to find the descendants and the ancestors of a node by creating an
index on the elements of the ancestors field. This makes *Array of
Ancestors* a good choice for working with subtrees.

The *Array of Ancestors* pattern is slightly slower than the
*Materialized Paths* pattern but is more straightforward to use.

Materialized Paths
``````````````````

The *Materialized Paths* pattern stores each tree node in a document;
in addition to the tree node, document stores as a string the id(s) of
the node's ancestors or path. Although the *Materialized Paths* pattern
requires additional steps of working with strings and regular
expressions, the pattern also provides more flexibility in working with
the path, such as finding nodes by partial paths.

Consider the following example that models a tree of categories using
*Materialized Paths* ; the path string uses the comma ``,`` as a
delimiter:

.. code-block:: javascript

   db.categories.insert( { _id: "Books", path: null } )
   db.categories.insert( { _id: "Programming", path: "Books," } )
   db.categories.insert( { _id: "Databases", path: "Books,Programming," } )
   db.categories.insert( { _id: "Languages", path: "Books,Programming," } )
   db.categories.insert( { _id: "MongoDB", path: "Books,Programming,Databases," } )
   db.categories.insert( { _id: "Postgres", path: "Books,Programming,Databases," } )

- You can query to retrieve the whole tree, sorting by the ``path``:

  .. code-block:: javascript

     db.categories.find().sort( { path: 1 } )

- You can create an index on the field ``path`` to enable fast search
  by the path:

  .. code-block:: javascript

     db.categories.ensureIndex( { path: 1 } )

- You can use regular expressions on the ``path`` field to find the
  descendants of ``Programming``:

  .. code-block:: javascript

     db.categories.find( { path: /,Programming,/ } )

Nested Sets
```````````

The *Nested Sets* pattern identifies each node in the tree as stops in
a round-trip traversal of the tree. Each node is visited twice; first
during the initial trip, and second during the return trip. The *Nested
Sets* pattern stores each tree node in a document; in addition to the
tree node, document stores the id of node's parent, the node's initial
stop in the ``left`` field, and its return stop in the ``right`` field.

Consider the following example that models a tree of categories using
*Nested Sets*:

.. code-block:: javascript

   db.categories.insert( { _id: "Books", parent: 0, left: 1, right: 12 } )
   db.categories.insert( { _id: "Programming", parent: "Books", left: 2, right: 11 } )
   db.categories.insert( { _id: "Languages", parent: "Programming", left: 3, right: 4 } )
   db.categories.insert( { _id: "Databases", parent: "Programming", left: 5, right: 10 } )
   db.categories.insert( { _id: "MongoDB", parent: "Databases", left: 6, right: 7 } )
   db.categories.insert( { _id: "Postgres", parent: "Databases", left: 8, right: 9 } )

You can query to retrieve the descendants of a node:

  .. code-block:: javascript

     var databaseCategory = db.v.findOne( { _id: "Databases" } );
     db.categories.find( { left: { $gt: databaseCategory.left }, right: { $lt: databaseCategory.right } } );

The *Nested Sets* pattern provides a fast and efficient solution for
finding subtrees but is inefficient for modifying the tree structure.
As such, this pattern is best for static trees that do not change.

.. seealso::

   - `Ruby Example of Materialized Paths
     <http://github.com/banker/newsmonger/blob/master/app/models/comment.rb>`_ 
   
   - `Sean Cribs Blog Post
     <http://seancribbs.com/tech/2009/09/28/modeling-a-tree-in-a-document-database/>`_ 
     which was the source for much of the :ref:`data-modeling-trees` content.

Queues 
~~~~~~

Consider the following ``book`` document that stores the number of
available copies:

.. code-block:: javascript
   :emphasize-lines: 9

   book = {
             _id: 123456789,
             title: "MongoDB: The Definitive Guide",
             author: [ "Kristina Chodorow", "Mike Dirolf" ],
             published_date: ISODate("2010-09-24"),
             pages: 216,
             language: "English",
             publisher_id: "oreilly",
             available: 3
           }

Using the :method:`db.collection.findAndModify()` method, you can
atomically find and decrement the ``available`` field as the book is
checked out:

.. code-block:: javascript

   db.books.findAndModify ( {
      query: { _id: 123456789 } ,
      update: { $inc: { available: -1 } } 
   } )

Additional Resources
--------------------

.. seealso::

   - `Schema Design by Example <http://www.10gen.com/presentations/mongodb-melbourne-2012/schema-design-example>`_

   - `Walkthrough MongoDB Data Modeling <http://blog.fiesta.cc/post/11319522700/walkthrough-mongodb-data-modeling>`_
      
   - `Document Design for MongoDB <http://oreilly.com/catalog/0636920018391/>`_

   - `Dynamic Schema Blog Post <http://dmerr.tumblr.com/post/6633338010/schemaless>`_

   - :wiki:`MongoDB Data Modeling and Rails`
