==========================
Data Modeling Introduction
==========================

.. default-domain:: mongodb

Data in MongoDB has a *flexible schema*. Unlike SQL databases, where
you must determine and declare a table's schema before inserting data,
MongoDB's :term:`collections <collection>` do not enforce
:term:`document` structure. This flexibility permits each document to
only hold the fields that are relevant to the entity or object that the
document represents. However, in practice the documents in a collection
share a similar structure.

The key challenge in data modeling is balancing the needs of the
application, the performance characteristics of database engine, and
the data retrieval patterns. When designing data models, always
consider the inherent structure of the data itself as well as the
application usage of the data (i.e. queries, updates, and processing of
the data).

Document Structure
------------------

The key decision in designing data models for MongoDB applications
revolves around the structure of documents and how the application
represents relationships between data. There are two approaches to
representing these relationships: *referencing* and *embedding*:

Referencing
~~~~~~~~~~~

Referencing denote the relationships between data by including links or
*references* from one document to another. Applications can then
resolve these :doc:`references </reference/database-references>` to
access the related data. Generally, these are *normalized* data models.

.. include:: /images/data-model-normalized.rst

See :ref:`data-modeling-referencing` for the strengths and weaknesses of 
using references.

Embedding
~~~~~~~~~

Embedding represents relationships between data by storing related data
in a single document structure. In MongoDB, embed related documents as
sub-documents in other documents. These *denormalized* data models
allow applications to request and retrieve related data in a single
database operation.

.. include:: /images/data-model-denormalized.rst

See :ref:`data-modeling-embedding` for the strengths and weaknesses of 
embedding subdocuments.

Atomicity of Write Operations
-----------------------------

In MongoDB, write operations are atomic at the :term:`document` level,
and no single write operation can atomically affect more than one
document or more than one collection. A denormalized data model with
embedded data would facilitate atomic write operations since the write
operation would generally update a single document.

However, schemas that facilitate atomic writes may limit ways that
applications can use the data or ways to redesign applications. The
:ref:`Atomicity Considerations <data-model-atomicity>` documentation
describes the challenge of designing a schema that balances flexibility
and atomicity.

Document Growth
---------------

Some updates, such as pushing elements to an array or adding new
fields, increase a :term:`document's <document>` size. If the document
size exceeds the allocated space for that document, MongoDB relocates
the document on disk. The growth consideration can affect the decision
to normalize or denormalize data. See :ref:`Document Growth
Considerations <data-model-document-growth>` for more about planning
for and managing document growth in MongoDB.

Data Use and Performance
------------------------

When designing a schema, consider how applications will use your
database. For instance, if your application only uses recently inserted
documents, consider using :doc:`/core/capped-collections`. Or if your
application needs are mainly read operations to a collection, adding
indexes to support common queries can improve performance.

See :doc:`/core/data-model-operations` for more information on these
and other operational considerations that affect data model designs.
