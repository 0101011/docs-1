==========================
Data Modeling Introduction
==========================

.. default-domain:: mongodb

Collections in MongoDB has a *flexible schema*. Unlike SQL databases
that require you to determine and declare a table's schema before
inserting data, MongoDB's :term:`collections <collection>` do not
enforce :term:`document` structure. The flexible schema enables
documents to only contain the fields that are relevant to the entity or
object represented by the document. In practice, *most* documents in a
collection share a similar structure, but they need not.

Although a number of data models may be functionally equivalent for a
given application, different data models will have different impacts on
MongoDB and application performance. When possible, develop data models
using real data and application code, and iterate to achieve the most
effective model for your application and use cases.

As in all data modeling, when designing schemas for MongoDB, you must
consider the inherent properties and requirements of the application
objects and the relationships between application objects. MongoDB data
models should also reflect how data will grow and change over time as
well as the kinds of queries your application will perform.

Document Structure
------------------

A key decision in designing data models in MongoDB is whether to
normalize data or denormalize data. Normalized data models use
:doc:`references </reference/database-references>` to describe
relationships between documents. With normalized models, applications
must issue follow-up queries to resolve the references.

Denormalized data models takes advantage of MongoDB's support for
embedded documents and keeps related data together. With denormalized
data models, applications can request and retrieve related data in a
single database operation.

:ref:`data-modeling-decisions` discusses the strengths and weaknesses
of each approach in detail.

Atomicity of Write Operations
-----------------------------

In MongoDB, write operations are atomic at the :term:`document` level,
and no single write operation can atomically affect more than one
document or more than one collection. A denormalized data model with
embedded data would facilitate atomic write operations since the write
operation would generally update a single document.

However, schemas that facilitate atomic writes may limit ways that
applications can use the data or ways to redesign applications. The
:ref:`Atomicity Considerations <data-model-atomicity>` documentation
describes the challenge of designing a schema that balances flexibility
and atomicity.

Document Growth
---------------

Some updates, such as pushing elements to an array or adding new
fields, increase a :term:`document's <document>` size. If the document
size exceeds the allocated space for that document, MongoDB relocates
the document on disk. The growth consideration can affect the decision
to normalize or denormalize data. See :ref:`Document Growth
Considerations <data-model-document-growth>` for more about planning
for and managing document growth in MongoDB.

Data Use and Performance
------------------------

When designing a schema, consider how applications will use your
database. For instance, if your application only uses recently inserted
documents, consider using :doc:`/core/capped-collections`. Or if your
application needs are mainly read operations to a collection, adding
indexes to support common queries can improve performance.

See :doc:`/core/data-model-operations` for more information on these
and other operational considerations that affect data model designs.
