==========================
Data Modeling Introduction
==========================

.. default-domain:: mongodb

Data in MongoDB has a *flexible schema*. Unlike SQL databases, where
you must determine and declare a table's schema before inserting data,
MongoDB's :term:`collections <collection>` do not enforce
:term:`document` structure. This underlying data model, permits each
document to only hold the fields that are relevant to the entity or
object that the document represents. However, in practice the
documents in a collection share a similar structure.

The key challenge in data modeling is balancing the needs of the
application, the performance characteristics of database engine, and
the data retrieval patterns. Always inform the design of schemas using
the inherent structure of the data itself in combination ways that the
application will query, update, and process the data.

Document Structure
------------------

The key decision in designing data models for MongoDB applications
revolves around the structure of documents and how the application
represents relationships between pieces of data. There are two
approaches to representing these relationships: *references* and
*embedding*:

**References**
   References store relationships between data by including links from
   one document to another document to describe the connection between
   the data. Applications can then resolve these :doc:`references
   </reference/database-references>` to capture related
   data. Generally these are *normalized* data models.

**Embedding**
   Embedding represents relationships between data by storing related
   data in a single structure. MongoDB supports embedding related
   documents as sub-documents in other documents. These *denormalized*
   data models, allow applications to request and retrieve related
   data in a single database operation.

:ref:`data-modeling-decisions` discusses the strengths and weaknesses
of each approach in detail.

Atomicity of Write Operations
-----------------------------

In MongoDB, write operations are atomic at the :term:`document` level,
and no single write operation can atomically affect more than one
document or more than one collection. A denormalized data model with
embedded data would facilitate atomic write operations since the write
operation would generally update a single document.

However, schemas that facilitate atomic writes may limit ways that
applications can use the data or ways to redesign applications. The
:ref:`Atomicity Considerations <data-model-atomicity>` documentation
describes the challenge of designing a schema that balances flexibility
and atomicity.

Document Growth
---------------

Some updates, such as pushing elements to an array or adding new
fields, increase a :term:`document's <document>` size. If the document
size exceeds the allocated space for that document, MongoDB relocates
the document on disk. The growth consideration can affect the decision
to normalize or denormalize data. See :ref:`Document Growth
Considerations <data-model-document-growth>` for more about planning
for and managing document growth in MongoDB.

Data Use and Performance
------------------------

When designing a schema, consider how applications will use your
database. For instance, if your application only uses recently inserted
documents, consider using :doc:`/core/capped-collections`. Or if your
application needs are mainly read operations to a collection, adding
indexes to support common queries can improve performance.

See :doc:`/core/data-model-operations` for more information on these
and other operational considerations that affect data model designs.
