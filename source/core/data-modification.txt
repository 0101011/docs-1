==================
Data Modifications
==================

.. default-domain:: mongodb

There are three classes of operation in MongoDB that modify data in a
:term:`collection`: insert, update, and remove. In MongoDB, all write
operations modify data of a single :term:`collection`. These operations
can act on a single document or multiple documents. For the update and
remove operations, you can specify criteria to select the documents to
modify.

Create
------

Create operations add new :term:`documents <document>` to a collection.
In MongoDB, the :method:`db.collection.insert()` method perform create
operations. The method can add one or multiple documents. See
:doc:`/core/bulk-inserts` for adding multiple documents.

.. example::

   .. code-block:: javascript

      db.users.insert( 
         {
            name: "sue",
            age: 26,
            status: "A"
         }
      )

   This operation inserts a new documents into the ``users``
   collection. The new document has four fields ``name``, ``age``, and
   ``status``, and an ``_id`` field. MongoDB always adds the ``_id``
   field to the new document if the field does not exist.

The following diagram highlights the components of a MongoDB insert
operation:

.. include:: /images/crud-annotated-mongodb-insert.rst

The following diagram shows the same query in SQL:

.. include:: /images/crud-annotated-sql-insert.rst

In addition to the :method:`db.collection.insert()` method, MongoDB
provides two additional methods for the create operation. Both the
:method:`db.collection.update()` method and the
:method:`db.collection.save()` method can perform an ``upsert`` which
can also insert new documents. 

An ``upsert`` is an operation that performs either an update of an
existing document or an insert of a new document if the document to
modify does not exist. With an ``upsert``, applications do not need to
make two separate calls to the database in order to decide between
performing an update or an insert operation. See
:method:`db.collection.update()` and :method:`db.collection.save()` for
details on performing an upsert with these methods.

Update
------

Update operations modify existing :term:`documents <document>` in a
:term:`collection`. In MongoDB, :method:`db.collection.update()` and
the :method:`db.collection.save()` methods perform update operations.
The :method:`db.collection.update()` method can accept a query criteria
to determine which documents to update as well as an option to update
multiple rows.

.. example::

   .. code-block:: javascript

      db.users.update( 
         { age: { $gt: 18 } },
         { $set: { status: "A" } },
         { $multi: true }
      )

   This update operation on the ``users`` collection sets the
   ``status`` field to ``A`` for the documents that match the criteria
   of ``age`` greater than ``18``.

The following diagram highlights the components of a MongoDB update
operation:

.. include:: /images/crud-annotated-mongodb-update.rst

The following diagram shows the same query in SQL:

.. include:: /images/crud-annotated-sql-update.rst

See :method:`db.collection.update()` and :method:`db.collection.save()`
for more information. 

Delete
------

Delete operations remove documents from a collection. In MongoDB,
:method:`db.collection.remove()` method performs delete operations. The
:method:`db.collection.remove()` method can accept a query criteria to
determine which documents to remove. In addition, the method can accept
a flag to limit the delete operation to a single document.

.. example::

   .. code-block:: javascript

      db.users.remove( 
         { status: "D" }
      )

   This delete operation on the ``users`` collection removes all
   documents that match the criteria of ``status`` equal to ``D``.

The following diagram highlights the components of a MongoDB remove
operation:

.. include:: /images/crud-annotated-mongodb-remove.rst

The following diagram shows the same query in SQL:

.. include:: /images/crud-annotated-sql-delete.rst

See :method:`db.collection.remove()` method for more information.

Behavior
--------

Document Insertion
~~~~~~~~~~~~~~~~~~

If you add a new document *without* the :term:`_id` field, the client
library or :program:`mongod` instance adds an ``_id`` field and
populates the field with a unique :term:`ObjectId <objectid>`.

If you specify the ``_id`` field, the value must be unique within the
collection. For operations with :ref:`write concern <write-concern>`,
if you try to create a document with a duplicate ``_id`` value,
:program:`mongod` returns a duplicate key exception.

Document Update and Modification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the :method:`db.collection.update()` method updates a
**single** document. However, with the ``multi`` option,
:method:`~db.collection.update()` can update all documents in a
collection that match a query.

:method:`db.collection.save()` method replaces a document, and can
only update a single document. See :method:`db.collection.save()`
and :doc:`/tutorial/insert-documents` for more information

The :method:`db.collection.update()` method either updates specific
fields in the existing document or replaces the document. See
:method:`db.collection.update()` for details.

.. include:: /includes/fact-update-field-order.rst

.. _write-operations-isolation:

Isolation of Write Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The modification of a single document, is always atomic even if the
write operation modifies multiple sub-documents *within* that
document. For write operations that modify multiple documents, the
operation as a whole is not atomic, and other operations may
interleave.

No other operations are atomic; however, you can attempt to isolate a
write operation that affects multiple documents using the
:doc:`isolation operator </reference/operator/isolated>`.

To isolate a sequence of write operations from other read and write
operations, see :doc:`/tutorial/perform-two-phase-commits`.

.. _write-operations-indexing:

Performance of Write Operations and Indexes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After every insert, update, or delete operation, MongoDB must update
*every* index associated with the collection in addition to the data
itself. Therefore, every index on a collection adds some amount of
overhead for the performance of write operations. [#exceptions]_

In general, the performance gains that indexes provide for *read
operations* are worth the insertion penalty; however, when optimizing
write performance, be careful when creating new indexes and always
evaluate the indexes on the collection and ensure that your queries are
actually using these indexes.

For more information on indexes in MongoDB, see :doc:`/indexes` and
:doc:`/applications/indexes`.

.. [#exceptions] The overhead for :ref:`sparse indexes <index-type-sparse>`
   inserts and updates to un-indexed fields is less than for non-sparse
   indexes. Also for non-sparse indexes, updates that don't change the
   record size have less indexing overhead.

Write Concern
~~~~~~~~~~~~~

.. include:: /includes/fact-write-concern.rst
