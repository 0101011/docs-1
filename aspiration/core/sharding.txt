.. index:: sharding

=====================
Sharding Fundamentals
=====================

.. default-domain:: mongodb

MognoDB's sharding allows users to :term:`partition` the
data of a :term:`collection` within a database so that the documents
are automatically distributed among a number of :program:`mongod`
instances. These systems provides a larger write capacity and allows a
single database instance to have a larger working set or total data
size than a single instance could supply.

This document provides an overview of the fundamental concepts and
operation of sharding with MongoDB.

.. seealso:: The ":doc:`/sharding`" index for a list of all documents
   in this manual that contain information related to the operation
   and use of shard clusters in MongoDB.

   If you are not yet familiar with sharding, see the :doc:`Sharding
   FAQ </faq/sharding>`.

Overview
--------

Features
~~~~~~~~

With sharding MongoDB automatically distributes data among a
collection of :program:`mongod` instances. Sharding, as implemented in
MongoDB has the following features:

.. glossary::

   Range Based Sharding
      MongoDB uses "range based" sharding, where the database
      distributes documents among :term:`shards` based on the value
      of the :ref:`shard key <sharding-shard-key>`. Each :term:`chunk`
      represents a block of :term:`document <documents>` with values
      that fall within a specific range. When chunks grow beyond the
      :ref:`chunk size <sharding-chunk-size>`, MongoDB divides the
      chunks into smaller chunks (i.e. :term:`splitting <split>`)
      based on the shard key.

   Automatic Sharding
      The sharding system will automatically balance data across the
      cluster, without intervention from the application
      layer. Effective automatic sharding depends on a well chosen
      :ref:`shard key <sharding-shard-key>`, but requires no
      additional complexity, modifications, or intervention for
      developers.

   Transparent Sharding
      Sharding is completely transparent to the application layer,
      because all connections to a sharded cluster go through the
      :program:`mongos` instances. Sharding in MongoDB requires some
      :doc:`basic initial configuration </administration/sharding>`,
      but ongoing function is entirely transparent to the application.

   Sharding Capacity
      Sharding increases capacity in two ways:

      #. Given an even distribution of data with an effective
         :term:`shard key`, sharding can provide additional write
         capacity by increasing the number of :program:`mongod`
         instances.

      #. Give a shard key with sufficent :ref:`cardnality
         <sharding-shard-key-cardnality>`, sharding makes it possible
         to distribute data among a collection of :program:`mongod`
         instances, and increase the potential amount of data to mange
         with MongoDB and expand the :term:`working set`.

A typical :term:`shard cluster` consists of the config servers that
provide metadata that maps :term:`chunks` to shards, the
:program:`mongod` instances that hold the data (i.e the :term:`shards
<shard>`,) and lightweight routing processes, :doc:`mongos
</reference/mongos>`, that routes operations to the correct shard
based on the operation and the cluster metadata.

Indications
~~~~~~~~~~~

While sharding is a very powerful and compelling feature, it comes with
significant :ref:`infrastructure requirements <sharding-requirements>`
and some limited complexity costs. As a result its important to use
sharding only as neccessary,and when indicated by actual operational
requirements. Consider the following overview of indications, or a
simple "*when you should shard,*" guide.

You should consider deploying a :term:`shard cluster`, if:

- your data set exceeds the storage capacity of a single node in your
  system.

- the size of your system's active :term:`working set` *will soon*
  exceed the capacity of the *maximum* amount of RAM for your system.

- your system has a large amount of write activity, and cannot write
  data fast enough to meet demand, and all other approaches have not
  reduced the contention.

TODO factcheck; make sure there aren't addition indications.

If these are not true of your system, sharding may add too much
complexity to your system without providing much benefit to your
system.

.. warning::

   Do not attempt to shard a collection when your system has already
   reached ore exceeded its capacity. Sharding takes some time to
   configure, and the :term:`balancer` process can take some time to
   migrate data and distribute content among the cluster.

   As a result if you know you're going to need sharding eventually,
   its crucial that you **do not** wait until your system is
   overcapacity to enable sharding.

.. _sharding-requirements:
.. index:: sharding; requirements

Requirements
------------

.. _sharding-requirements-infrastructure:

Infrastructure
~~~~~~~~~~~~~~

A :term:`shard cluster` has the following components:

- Three :term:`config servers`.

  These special :program:`mongod` instances store the configuration
  meta data for the cluster. The :program:`mongos` instances cache
  this data, and use it to determine which :term:`shard` is
  responsible for which :term:`chunk`.

  For testing purposes you can deploy a shard cluster with a single
  configuration server, but this is not recommended for production.

- One or more :program:`mongos` instances.

  These nodes cache cluster configuration from the configuration
  servers and direct queries from the application layer to the
  :program:`mongod` instances that hold the data.

  .. note::

     :program:`mongos` *Resource use:*

     In most situations :program:`mongos` instances use minimal
     resources, and you can run them on your application servers
     without impacting application performance. However, if you use
     the :term:`aggregation framework` some processing may occur on
     the :program:`mongos` instances which will cause them to require
     more system resources.

- Two or more :program:`mongod` instances, to hold data.

  These are "normal," :program:`mongod` instances that hold all of the
  actual data for the cluster.

  Typically a :term:`replica sets` provides each individual shard,
  which provides redundancy for all data in the cluster and increases
  the overall reliability and robustness of the cluster.

  .. warning::

     MongoDB enables data :term:`partitioning <partition>`
     (i.e. sharding) on a *per collection* basis. You *must* access
     all data in a sharded cluster via the :program:`mongos`.

Data
~~~~

In most cases, there must be a significant quantity of data for
sharding to have an effect on your collection. The default
:term:`chunk` size is 64 megabytes, [#chunk-size]_ and the
:ref:`balancer <sharding-balancing>` will not kick in until there is a
difference of 8 chunks between the shard with the most number of
chunks and the shard with the least number of chunks.

Practically, this means that unless there is 512 megabytes of data,
all of the data will remain on the same shard. You can set a smaller
chunk size, or create splits in your collection using the
:func:`sh.splitFind()` or :func:`sh.splitAt()` operations in the
:program:`mongo` shell to facilitate chunks, but these defaults are
explicitly configured to prevent unnecessary splitting or migrations.

While there are some exceptional situations where you may need to
shard a small collection of data, most of the time the additional
complexity added by sharding is not worth the operational costs unless
you need the additional concurrency/capacity for some reason. If you
have a small data set, the chances are that a properly configured
single MongoDB instance or replica set will be more than sufficient
for your data service needs.

TODO link this section to <glossary:chunk size>

.. index:: chunk size
   single: sharding; chunk size

.. _sharding-chunk-size:

.. [#chunk-size] While the default chunk size is 64 megabytes, the
   size is :option:`user configurable <mongos --chunkSize>`. When
   deciding :term:`chunk` size, MongoDB (for defaults) and users (for
   custom values) must consider that: smaller chunks offer the
   possibility for a more even data distribution, but increase the
   likelihood of chunk migrations. Larger chunks decrease the need for
   migrations, but increase the amount of time required for a chunk
   migration.

   When chunks grow beyond the :ref:`specified chunk size
   <sharding-chunk-size>` a :program:`mongos` instance will split the
   chunk in half, which will eventually lead to migrations, when
   chunks become uneavenly distributed among the cluster, the
   :program:`mongos` instances will initiate a round migrations to
   redistribute data in the cluster.

TODO link this section to <glossary:shard key>

.. _shard-key:
.. _sharding-shard-key:

.. index:: shard key
   single: sharding; shard key

Shard Keys
----------

"Shard keys" refer to the :term:`field` in a MongoDB :term:`document`
that that MongoDB uses to distribute documents among the
:term:`shards`. Shard keys, like :term:`indexes`, can be either a
single field, or may be a compound key, consisting of multiple fields.

Remember, MonoDB's sharding is range-based: each :term:`chunk` holds
documents with "shard key" within a specific range. Thus, choosing the
correct shard key can have a great impact on the performance,
capability, and functioning of your database and cluster.

Choosing a shard key is something that depends on the schema of your
data and your useage patterns. The ideal shard key:

- is easily divisable which makes it easy for MongoDB to distribute
  content among the shards. Shard keys that have a limited number of
  possible values are inideal, as they can result in some shards that
  are "unsplittable."

  .. see:: ":ref:`sharding-hard-key-cardnality`"

- will distribute write operations among the cluster, to prevent any
  single shard from becoming a bottleneck. Shard keys that have a high
  correlation with insert time are poor choices for this reason;
  however, shard keys that have higher "randomness" satisfy this
  requirement better.

  .. see:: ":ref:`sharding-hard-key-scaling`"

- will make it possible for the :program:`mongos` to return most query
  operations directly to a single *specific* :program:`mongod`
  instance. Your shard key should be the primary field used by your
  queries, and fields with a high amount of "randomness" are poor
  choices for this reason.

  .. see:: ":ref:`sharding-hard-key-scaling`"

The challenge when selecting the shard key is that there is not always
an obvious shard key, and that it's unlikely that a single naturally
occuing [#computed-shard-key] field in your collection will satisfy
all requirements. Computing a special-purpose shard key, or using a
compound shard key can help you find a more ideal shard key, but the
shard key always some degree of compromize.

TODO add something about the order of the shard keys

.. [#computed-shard-key] In some cases, you may consider computing a
   a more sutable shard key for each document in your application and
   adding it to all of the documents before sharding.

TODO move the remainder of this section (or most of it) to internals doc

.. _sharding-shard-key-cardnality:
.. index:: shard key; cardnality

Cardinality
~~~~~~~~~~~

Cardnality refers to the property of the dataset that allows MongoDB
to split it into :term:`chunks`. For example, consider a collection
of data such as an "address book" that stores address records:

- Consider using use the ``state`` field, which holds the US state for
  the contact, as a shard key. This field has a *low cardnality*. All
  documents that had the same value in the ``state`` field *must*
  reside on the same shard, even if the chunk excedes the chunk
  size.

  Because there are a limited number of possible values for this
  field, among which your data may not be evenly distributed, you risk
  having data distributed unevenly among a fixed or small number of
  chunks. In this may have a number of effects:

  - If one chunk has a fixed size that grows beyond the chunk size,
    migrations involving this chunk will take longer than other
    migrations, which may affect the performance of some components of
    the cluster.

  - If you have a fixed maximum number of chunks you will never be
    able to utilize more than that number of shards for this
    collection.

- Consider using the ``postal-code``" field (i.e. zip code,) while
  this field has a large number of possible values, and thus has
  *higher cardanlity,* it's possible that a large number of users
  could have the same value for the shard key, which ould make this
  chunk of users unsplitable.

  In these cases, cardnality depends on the data. If your addressbook
  stores records for a geographically distributed contact list
  (e.g. "Dry cleaning businesses in America,") then a value like
  ``postal-code`` would be sufficent. However, if your addressbook is
  more geographically concentrated (e.g "ice cream stores in Boston
  Massachucets,") then you may have a much lower cardanlity.

- Consider using the "``phone-number``" field, which would hold the
  contact's telephone number. This number has a *higher cardnality,*
  becasue every (or most) users will have different values for this
  field, MongoDB will be able to split in as many chunks as
  needed.

While "high cardnality," is neccessary for ensuring an even
distribution of data, having a high cardnailty does not garentee
sufficent :ref:`query isolation <sharding-shard-key-query-isolation>`
or approrite :ref:`write scaling <sharding-shard-key-write-scaling>`.

.. _sharding-shard-key-write-scaling:
.. index:: shard key; write scaling

Write Scaling
~~~~~~~~~~~~~

TODO add ObjectID to glossary.

Some potential shard keys allow your application to take advantage of
the increased write capactiy that the shard cluster can provide, while
others do not. Consider using the default :term:`_id` field, which
holds an :term:`ObjectID`.

The ``ObjectID`` holds a value, computed upon creation, that is a
unique identifer for the object. However, the most signifigant data in
this value is effectively a timestamp, which means that they increment
in a regular and predictable pattern. Even though this value has
:ref:`high cardnality <sharding-shard-key-high-cardnality>`, when
this, or *any date or other incrementing number* as the shard key all
insert operations will always end up on the same shard. As a result,
the capacity of this node will become the effective capacity of the
cluster.

Unless you have a very low insert rate, most of your write operations
are :func:`update()` operations distributed throughout your entire
data set, **and** you're sharding to support a large data set, avoid
these date-based shard keys. Instead, choose shard keys that have both
high cardnality and that will generally distribute write operations
among the *entire cluster*.

Typically, a shard key that has some amount of "randomness," like a
cryptographic hash (i.e. MD5 or SHA1,) will provide the ability for
write scaling. However, random hashes do not typically provide
:ref:`query isolation <sharding-shard-key-query-isolation>`, which is
an important characteristic of shard keys.

Querying
~~~~~~~~

.. _sharding-shard-key-query-isolation:
.. index:: shard key; query isolation

Query Isolation
```````````````

Sorting Data
````````````

Operations
~~~~~~~~~~

Reiliabiliity
`````````````

Index Optimization
``````````````````

Choosing a Shard Key
~~~~~~~~~~~~~~~~~~~~

.. _sharding-configuration-servers:

Config Servers
--------------

TODO write configuration server section

The configuration servers store the shard metadata which keeps track

- read only mode.
- two phase commits for consistancy.

.. _sharding-mongos:

.. index:: mongos

:program:`mongos`
-----------------

TODO write mongos overview section

run anywhere
routing processes.

.. note::

   The :term:`aggregation` framework provided by the
   :dbcommand:`aggregate` command can

.. _sharding-balancing:

TODO plan balancing section

Balancing and Distribution
--------------------------

Balancing Procedure
~~~~~~~~~~~~~~~~~~~

Shard Size
~~~~~~~~~~

Architecture Possibilities
--------------------------
