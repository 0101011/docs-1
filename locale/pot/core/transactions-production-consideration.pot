# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2019
# This file is distributed under the same license as the mongodb-manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-19 11:02-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/transactions-production-consideration.txt:3
msgid "Production Considerations"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:14
msgid "Feature Compatibility"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:16
msgid "The ``featureCompatibilityVersion`` of all members of the replica set must be ``4.0`` or greater."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:22
msgid "Runtime Limit"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:24
msgid "By default, a transaction must have a runtime of less than one minute. You can modify this limit using :parameter:`transactionLifetimeLimitSeconds`. Transactions that exceeds this limit are considered expired and will be aborted by a periodic cleanup process."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:31
msgid "Oplog Size Limit"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:33
msgid "When the transaction commits, a single :doc:`oplog (operations log) </core/replica-set-oplog>` entry is created if the transaction contains any write operations. That is, the individual operations in the transactions do not have a corresponding oplog entry. Instead, a single oplog entry contains all of the write operations within a transaction. The oplog entry for the transaction must be within the BSON document size limit of 16MB."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:42
msgid "WiredTiger Cache"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:44
msgid "To prevent storage cache pressure from immobilizing the system:"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:46
msgid "When you abandon a transaction, abort the transaction."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:48
msgid "When you encounter an error during individual operation in the transaction, abort the transaction and retry the transaction."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:51
msgid "The :parameter:`transactionLifetimeLimitSeconds` also ensures that expired transactions are aborted periodically to relieve storage cache pressure."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:57
#: ../source/core/transactions-production-consideration.txt:67
msgid "By default, transactions waits up to ``5`` milliseconds to acquire locks required by the operations in the transaction. If the transaction cannot acquire its required locks within the ``5`` milliseconds, the transaction aborts."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:65
msgid "Transactions and Locks"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:72
msgid "Transactions release all locks upon abort or commit."
msgstr ""

#: ../source/includes/extracts/transactions-operations-catalog-tip.rst:4
msgid "When creating or dropping a collection immediately before starting a transaction, if the collection is accessed within the transaction, issue the create or drop operation with write concern :writeconcern:`\"majority\"` to ensure that the transaction can acquire the required locks."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:77
msgid "Lock Request Timeout"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:79
msgid "You can use the :parameter:`maxTransactionLockRequestTimeoutMillis` parameter to adjust how long transactions wait to acquire locks. Increasing :parameter:`maxTransactionLockRequestTimeoutMillis` allows operations in the transactions to wait the specified time to acquire the required locks. This can help obviate transaction aborts on momentary concurrent lock acquisitions, like fast-running metadata operations. However, this could possibly delay the abort of deadlocked transaction operations."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:88
msgid "You can also use operation-specific timeout by setting :parameter:`maxTransactionLockRequestTimeoutMillis` to ``-1``."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:94
msgid "Pending DDL Operations and Transactions"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:96
msgid "If a multi-document transaction is in progress, new DDL operations that affect the same database(s) wait behind the transaction. While these pending DDL operations exist, new transactions that access the same database as the pending DDL operations cannot obtain the required locks and will abort after waiting :parameter:`maxTransactionLockRequestTimeoutMillis`. In addition, new non-transaction operations that access the same database will block until they reach their ``maxTimeMS`` limit."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:105
msgid "To illustrate, compare the following two situations:"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:107
msgid "Consider a situation where an in-progress transaction performs various CRUD operations on the ``employees`` collection in the ``hr`` database. While that transaction is in progress, a separate transaction that accesses the ``foobar`` collection in the ``hr`` database can start and complete."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:113
msgid "However, consider a situation where an in-progress transaction performs various CRUD operations on the ``employees`` collection in the ``hr`` database and a separate DDL operation is issued to create an index on the ``fluffy`` collection in the ``hr`` database. The DDL operation waits for the transaction to finish."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:119
msgid "While the DDL operation is pending, a new transaction attempts to access the ``foobar`` collection in the ``hr`` database. If the DDL operation remains pending for :parameter:`maxTransactionLockRequestTimeoutMillis`, the new transaction aborts."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:127
msgid ":ref:`transactions-write-conflicts`"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:129
msgid ":ref:`transactions-stale-reads`"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:134
msgid "In-progress Transactions and Write Conflicts"
msgstr ""

#: ../source/includes/extracts/transactions-write-conflict.rst:2
msgid "If a multi-document transaction is in progress and a write outside the transaction modifies a document that an operation in the transaction later tries to modify, the transaction aborts because of a write conflict."
msgstr ""

#: ../source/includes/extracts/transactions-write-conflict.rst:7
msgid "If a multi-document transaction is in progress and has taken a lock to modify a document, when a write outside the transaction tries to modify the same document, the write waits until the transaction ends."
msgstr ""

#: ../source/core/transactions-production-consideration.txt:140
msgid ":ref:`txns-locks`"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:141
msgid ":ref:`txn-prod-considerations-ddl`"
msgstr ""

#: ../source/core/transactions-production-consideration.txt:146
msgid "In-progress Transactions and Stale Reads"
msgstr ""

#: ../source/includes/extracts/transactions-stale-reads.rst:2
msgid "Read operations take an intent lock. As such, read operations inside a transaction can return stale data. For example, consider the following sequence: 1) a transaction is in-progress 2) a write outside the transaction deletes a document 3) a read operation inside the transaction is able to read the now-deleted document since the operation is using a snapshot from before the write."
msgstr ""

#: ../source/includes/extracts/transactions-stale-reads.rst:9
msgid "To avoid stale reads inside transactions for a single document, you can use the :method:`db.collection.findOneAndUpdate()` method. For example:"
msgstr ""

#: ../source/includes/extracts/transactions-stale-reads.rst:25
msgid "If the employee document has changed outside the transaction, then the transaction aborts."
msgstr ""

#: ../source/includes/extracts/transactions-stale-reads.rst:28
msgid "If the employee document has not changed, the transaction returns the document and locks the document."
msgstr ""

