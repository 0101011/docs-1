=================================================
Expire Least Recently Used Data from a Collection
=================================================

.. default-domain:: mongodb

.. versionadded:: 2.2

.. walk away from article so that it can be useful.
.. read aloud to self
.. few
.. --> passive; more direct to outline that the system will delete things.

.. specify that the 'application' is the one responsible for updating the field
.. clear up examples - application 
.. specify that the 'system' deletes the information - application's reponsibility to keep things alive

Use Cases
---------

.. good, but no syntatic - group (i.e.) into own sentences
- client & server states (i.e. web sessions, client state information)
- file caches (i.e. keep recently used files online, move unused files to archives)
- particular server logs (i.e. keep active server logs, remove inactive server logs)

.. --> passive; more direct to outline that the system will delete things.
In these cases, the most recently accessed documents are important
while older unused documents should be removed from the collection.

Solution
--------

MongoDB has a :term:`TTL` collection that :progam:`mongod` will
automatically remove any documents from the collection that are older
than specified period.  In a :term:`TTL` collection, to keep any document
from being deleted, update the date field of the document within
the :term:`TTL` duration.

#. Create collection with proper date field.
#. Create TTL Index for the collection with ``expireAfterSeconds``.
#. Update the date field of any document to stay in the collection.

Pattern
-------

.. token too general --> switch up to 'events' (i.e. events log)
.. token kinda sounds like a real thing

cacheing web pages in memory
- you have a web server that serves web pages
- web pages are stored in memory and disk
- want to have system to decide which pages to keep in memory (and
  which pages to put to disk)

The access time of a web page for a server are recorded in an
``eventLog``. Web pages that are accessed will be
maintained in memory, old web pages that have not been accessed over
an hour will be removed from memory, for more pages to be ca

The ``eventLog`` collection would be:

.. code-block:: javascript

   { "_id" : ObjectId("..."), "pageID" : 100, "accessTime" : ISODate("2012-08-02T17:47:15.275Z") }
   { "_id" : ObjectId("..."), "pageID" : 101, "accessTime" : ISODate("2012-08-02T17:47:27.764Z") }
   { "_id" : ObjectId("..."), "pageID" : 102, "accessTime" : ISODate("2012-08-02T17:47:34.788Z") }

An ``eventLog`` collection that can be created by using the following commands:

.. code-block:: javascript

   > db.eventLog.insert( { pageID: 100, accessTime: new ISODate() })
   > db.eventLog.insert( { pageID: 101, accessTime: new ISODate() })
   > db.eventLog.insert( { pageID: 102, accessTime: new ISODate() })

Create a 60 minute TTL index on this collection by using command:

.. code-block:: javascript

   db.tokenLog.ensureIndex( { accessTime: 1 }, { expireAfterSeconds: 3600 } )

:program:`mongod` will now remove any pages in this collection that have not been accessed
in over an hour.



When a ``token`` is accessed, update only its ``accessTime`` field
with the current time and date. For example, if ``token:101`` is
accessed again, update the ``accessTime`` field of ``token:101`` by
using the command:


Update any pages that have been accessed in the ``eventLog`` by using command:

.. code-block:: javascript

   db.eventLog.update( { pageID: 101 }, { $set: { accessTime: new ISODate() } } )

.. another set of example for the 
.. naming 


use case:
keep authenticated user information in the system. if they don't access the
system after a certain period, destroy authentication and force them
to reauthenticate
- web mail
- bank login
- 

- upon successful authentication, insert information into collection
- on every server access from user, check authentication info, update
  date entry on user
- after no access from user, mongod will automatically delete
  information


- insert user information after successful authentication
- on next access, check if user is authenticated or not
- update date field for user after server access
- if user is not on authenticated list, force reauthentication


The ``authenticationLog`` collection could be:

.. code-block:: javascript

   { "_id" : ObjectId("..."), ..., "userID" : 000, "accessTime" : ISODate("2012-08-02T17:47:15.275Z") }
   { "_id" : ObjectId("..."), ..., "userID" : 001, "accessTime" : ISODate("2012-08-02T17:47:27.764Z") }
   { "_id" : ObjectId("..."), ..., "userID" : 002, "accessTime" : ISODate("2012-08-02T17:47:34.788Z") }

An ``authenticationLog`` collection that can be created by using the following commands:

.. code-block:: javascript

   > db.authenticationLog.insert( { userID: 100, accessTime: new ISODate() })
   > db.authenticationLog.insert( { userID: 101, accessTime: new ISODate() })
   > db.authenticationLog.insert( { userID: 102, accessTime: new ISODate() })

Verify the user has been authenticated recently:

.. code-block:: javascript

   db.authenticationLog.find( { userID: 101 } )

On access from the user, update the users' access time:

.. code-block:: javascript

   db.authenticationLog.update( { userID: 101 }, { $set: { accessTime: new ISODate() } } )

