===============
Read Operations
===============

.. default-domain:: mongodb

This document how MongoDB performs read operations.

MongodDB uses read operations when you retrieve collection data by using
a query.

.. TODO intro and high-level read operations info

.. For information about queries, see ???.

.. index:: read operation; query
.. index:: query; read operations
.. _read-operations-query-operators:

Query Operations
----------------

.. _read-operations-query-syntax:

Query Syntax
~~~~~~~~~~~~

For a list of query operators, see :doc:`/reference/operators`.

.. TODO see the yet-to-be created query operations doc

.. _read-operations-query-optimization:

Query Optimization
~~~~~~~~~~~~~~~~~~

The MongoDB query optimizer matches a query to the best index for
performing that query. When the optimizer finds the best index, it
creates a query plan so that the query will always use the specified
index.

The MongoDB query optimizer deletes a query plan when a collection has
changed to a point that the the specified index might no longer provide
the fastest results.

Query plans take advantage of MongoDB's indexing features. You should
always write indexes that use the same fields and sort in the same order
as do your queries.

MongoDB creates a query plan as follows: When you run a query for which
there is no query plan, either because the query is new or the old plan
is obsolete, the query optimizer runs the query against several indexes
at once in parallel. Though the optimizer queries the indexes in
parallel, it records the results as though all coming from one index.
The optimizer records all matches in a single common buffer.

As each index yields a match, MongoDB records the match in the buffer.
If an index returns a result already returned by another index, the
optimizer recognizes the duplication and skips recording the match
a second time.

The optimizer determines a "winning" index and stops querying when either of
the following occur:

- The optimizer exhausts an index, which means that index has provided
  the full result set the fastest.

- The optimizer reaches 101 results. At that point, the optimizer
  chooses the plan that has provided the most results *first* and
  continues reading only from that plan. Note that another index might
  have provided all those results as duplicates but because the "winning"
  index provided the results faster, it is the most efficient index.

The "winning" index now becomes the index specified in the query plan as
the one to use the next time that query is run.

To evaluate the optimizer's choice of query plan, run the query again
with the :method:`explain() <cursor.explain()>` method and
:method:`hint() <cursor.hint()>` methods appended. This returns
statistics about how the query runs. (It returns the statistics in place
of returning the query results.)

.. code-block:: javascript

   db.people.find( { name:"John"} ).explain().hint()

.. For details on the output of the :method:`explain()
   <cursor.explain()>` method, see ...

If you run :method:`explain() <cursor.explain()>` without including
:method:`hint() <cursor.hint()>`, the query optimizer will re-evaluate
the query, running multiple query plans, before it returns the query
statistics. Unless you want the optimizer to re-evaluate the query, do
not leave off :method:`hint() <cursor.hint()>`.

Because your collections will likely change over time, the query
optimizer uses the query plan only to a certain point.

.. Order of buffer results is different because coming from different
   indexes. Not ordered on one index.

.. Sorting >> all query plans are ordered vs none vs some.

.. "Optimal" is determined from a past run of multiple plans. But that
   cache gets cleared if there's been multiple writes.

.. Speculative scan of multiple plans.

.. Sparce indexes can change a result set.

.. Interleaving of results sets from multiple indexes ocurrs only when
   query plan is being determined. Once query plan is cached, then it's
   going to use one index.

.. What validates a cache: 1000 doc writes (not write operations but
   actual doc writes). Also if reindex or restart mongod.

.. Interweaving/leaving plans is done with cursor.

.. Dupe on disk lock and not on ID.

.. First time it runs the query (the first time it picks a query plan),
   it runs union of all query plans deemed to be potentially useful to
   return results set. Second time run the same query, it runs a single
   query plan.

.. Therefore, you can run the same query twice in a row and get the
   same results ordered differently.

.. And when you run explain, you also get different statistics.

.. END OF MY NOTES ON THE TECH TALK, EXCEPT FOR THE NOTES ON SPECIFIC
   OPTIMIZATION OPERATORS, such as $elemMatch

Selective Indexes Return Fastest Results
````````````````````````````````````````

The most selective indexes return the fastest results. The most
selective index possible for a given query is an index for which all the
documents that match the query criteria also match the entire query.

.. example::

   Consider the following indexes, data, and query:

   Indexes:

   .. code-block:: javascript

      { x:1 }, { y:1 }

   Data:

   .. code-block:: javascript

      { x:1, y:2 }
      { x:2, y:1 }
      { x:3, y:0 }
      { x:4, y:0 }

   Query:

   .. code-block:: javascript

      { x:{ $gte:1 } , y:{ $gte:1} }

   The ``{ y:1 }`` index is more selective because all the documents
   that match the query's ``y`` key value also match the entire query.
   Conversely, not all the documents that match the query's ``x`` key
   value also match the entire query.

.. _read-operations-projection:

Projection
~~~~~~~~~~

quick. and short.

.. _read-operations-indexing:

Indexing
~~~~~~~~

.. seealso:: :doc:`/core/indexes`

- :doc:`/reference/operators`
- :method:`find <db.collection.find()>`
- :method:`findOne`

.. _read-operations-aggregation:

Aggregation
~~~~~~~~~~~

Probably short, but there's no docs for old-style aggregation so.

- basic aggregation (count, distinct)
- legacy agg: group
- big things: mapreduce, aggregation

.. seealso:: :doc:`/applications/aggregation`

.. index:: read operation; architecture
.. _read-operations-architecture:

Architecture
------------

.. index:: read operation; connection pooling
.. index:: connection pooling; read operations
.. _read-operations-connection-pooling:

Connection Pooling
~~~~~~~~~~~~~~~~~~

Shard Clusters
~~~~~~~~~~~~~~

Replica Sets
~~~~~~~~~~~~

