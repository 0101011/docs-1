==================
Geospatial Indexes
==================

.. default-domain:: mongodb

Overview
--------

.. TODO beef this up.

MongoDB can store and query geospatial data with a focus on
location-based queries.

MongoDB supports geospatial data by creating a special index for
location data points. The index is a geohash calculated based on the
range and data points.

To use geospatial functions in MongoDB, you have to structure the
location data in a 2D array and make an index on this location
data with special options.

When you query for locations against the geospatial index, MongoDB
will automatically query against the geohash index, as well as other
index configuration.

.. include:: /includes/geospatial-coordinates.rst

.. _geospatial-indexes:

Geospatial Indexes
------------------

In order for MongoDB to use geospatial data, you must specify
MongoDB to create a geospatial index on the location data in your
collection. 

.. see:: :ref:`geospatial-coordinates` for an overview on modeling
   location data in MongoDB.

To create a geospatial index, use an operation modeled on the
following prototype:

.. code-block:: javascript

   db.collection.ensureIndex( { <location field> : "2d" } )

These operations will create a special index on location field in the
specified collection. These indexes use :ref:`geospatial-geohash`. All
geospatial queries will use this geospatial index.

.. note::

   MongoDB only supports *one* geospatial index per collection. As
   with all indexes in MongoDB, any single query will only be able to
   use one index. If a collection were to have more than one
   geospatial index, geospatial queries could not return consistent
   results.

.. _geospatial-indexes-range:

Range
~~~~~

All geospatial indexes are bounded and MongoDB will return an error
and reject documents with coordinate pairs outside of these
boundaries. The default boundaries support global coordinate data
(i.e. latitude and longitude for points on Earth,) are between -180
inclusive, and 180 non-inclusive.

To specify the boundaries of a geospatial index, use the ``min`` and
``max`` operators with the :func:`ensureIndex() <db.collection.ensureIndex()>`
operation, as in the following prototype.

.. code-block:: javascript

   db.collection.ensureIndex( { <location field>: "2d" } ,
                              { min: <lower bound> , max: <upper bound> } )

The following operation will create an index on the  ``places``
collection, for coordinates in the ``loc`` field, with boundaries
between ``-90`` and ``90``:

.. code-block:: javascript

   db.places.ensureIndex( { loc: "2d" } ,
                           { min: 90 , max: 90 } )

.. _geospatial-indexes-precision:

Precision
~~~~~~~~~

Geospatial indexes record precision, or resolution, in "bits", which
are configurable during index creation. If a geospatial index has a
higher bits setting, MongoDB will be able to return more precise
results from the index. However, lower resolution indexes provide
faster performance. For more information, please refer to the
:ref:`precision <geospatial-indexes-precision>` section.

By default, geospatial indexes in MongoDB have 26 bits of precision
and supports as many as 32 bits of precision. You can set the
precision of a geospatial index during creation by specifying the
``bits`` option to the :func:`ensureIndex()
<db.command.ensureIndex()>` method, as in the following example.

.. code-block:: javascript

   db.collection.ensureIndex( {<location field>: "2d"} ,
                              { bits: <bit precision> } )

You may create an index with fewer than 26 bits *if* your the data in
your collection is less precise and/or you're willing to sacrifice
precision in exchange for query speed.

Compound Indexes
~~~~~~~~~~~~~~~~

MongoDB supports :term:`compound indexes <compound index>` where one component is a
coordinate in a geospatial index, and the other coordinate is one or
more fields. This means that, for some operations, MongoDB will be
able to use this index for a larger portion of an operation, which
will improve performance for these queries.

Use an operation that resembles the following prototype command to
create a compound geospatial index.

.. code-block:: javascript

   db.collection.ensureIndex( { <location field>: "2d", <field>: 1 } );

These compound indexes support queries where you must filter both by
location and by another field. For example, if you need to return a
list of restaurants near a given point, but you want to optionally
select only restaurants that match a certain type (i.e. "take-out," or
"bar" stored in a ``type`` field.)

See the :ref:`index-type-compound` section for more information on
geospatial indexes.

.. note::

   Limits in geospatial queries are always applied to the geospatial
   component first. This will affect your result set if you specify
   additional sort operations.

Haystack Index
~~~~~~~~~~~~~~

Geospatial haystack indexes makes it possible to build a special ``bucket``
collection that better support queries that operate within a
limited area. For more information, please refer to :doc:`Geospatial
Indexes </core/geospatial-indexes>`

To build a geospatial index, specify the ``geoHaystack`` for the
location field and a ``bucketSize`` parameter . The ``bucketSize``
parameter determines the granularity of the bucket index. A
``bucketSize`` of 1 creates an index where keys within 1 unit of
longitude or latitude are stored in the same bucket.

.. code-block:: javascript

   db.collection.ensureIndex({ <location field>: "geoHaystack", type: 1 },
                             { bucketSize: <bucket value> })

By default, all queries on a geospatial haystack index returns 50
documents.

For example, to index all restaurants in a particular area with a
given maximum distance of 6 degrees longitude or latitude to accelerate
searches in this area, create the index using the following command:

.. code-block:: javascript

   db.places.ensureIndex({ loc: "geoHaystack", type: 1} ,
                          { bucketSize: 6 } )

Haystack indexes allow you to tune your bucket size to the
distribution of your data, so that queries only search a very small
region of 2D space for a particular kind of document. Haystack
indexes are not suited to finding the closest documents to a
particular location, as the closest documents could be far away
compared to the bucket size.

.. _geospatial-spherical-representation:

Spatial Representation Systems
------------------------------

MongoDB supports two systems for representing and returning geospatial
results. The default representation is flat and assumes that the
coordinates represent points on a flat plane. While this
representation is sufficient for many applications, points that refer
to locations on a spherical plane (i.e. coordinates on Earth) then
spherical queries will provide more accurate results.

.. note::

   There is no difference between flat and spherical *data* as stored
   in MongoDB. Rather, the only difference between spherical and flat
   geospatial systems in MongoDB is in the **queries**.

In general, the flat system is easier and accurate for system data
sets, but may return imprecise or skewed results if your coordinate
system reflects points on a curved plane, like the Earth's surface.

For more information on spherical and flat queries see the
:ref:`geospatial-representation-system` section and for more
information on query operations for spherical systems see the
:ref:`spherical queries <geospatial-query-spherical>` section.

Geohash
-------

.. TODO this is really an internals stuff

When creating a geospatial index, MongoDB will compute a location's
geohash value. A geohash value is a binary representation of the
location on a coordinate grid.

Geohash values are generated by continuously dividing a 2D map into
quadrants. Each quadrant is assigned a two bit value. A basic two bit
assignment for each quadrant could be:

.. code-block:: javascript

   01  11

   00  10

.. TODO color code these bits?

These two bit values (00, 01, 10, 11) each represent one of the four
quadrants. If a point exists in any of these quadrants, a set of two
bits will be assigned to describe the location.

To describe the point's location in more detail using the geohash, the
map will be further divided within the same quadrant and another two
bits will be assigned to the point. This point now has 2x two bits
representing its location, four bits total.

As the map is further divided, another two bit value is
assigned. Further divisions will provide additional accuracy with more
bits.

.. TODO insert graphical example to describe? It would be 'nice' for
.. those that REALLy want to know...

.. TODO this doesn't show up in the draft HTML

.. includes:: /includes/geospatial-sharding.rst
