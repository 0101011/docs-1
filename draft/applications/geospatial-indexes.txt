
.. This is the applications file 

.. cases where you would use it
.. quasi-use cases
.. examples of it in use
.. limitations
.. next steps? 

=====================
Using Geospatial Data
=====================

MongoDB supports rich queries and interaction with geospatial data to
store and query data based on location and proximity. This document
describes how to use geospatial indexes and associated operators. For
more information about the geospatial indexes and its operations see
:doc:`Geospatial Indexes </core/geospatial-indexes>`.

Create Geospatial Indexes
-------------------------

Ensure your geospatial data is stored in a collection in a 2
dimensional array, ``[x,y]`` or ``[y,x]``. For longitude-latitude data,
``[latitude,longitude]`` order is recommended.

To create a geospatial index, use the following operation:

.. code-block:: javascript

   db.collection.ensureIndex( { <location field> : "2d" } )

The field specified by the index must store geospatial
coordinates. The preferred format is:

.. code-block:: javascript

   [x,y]

But you may also use an embeded document, as in:

.. code-block:: javascript

   { x: 1, y: 2 }

The order of the coordinates doesn't matter, but you should be
consistent throughout your data set. If you use latitude-longitude
values as your coordinate system, always store latitude values first,
for consistency.

MongoDB will create an index from the location field which will
consist of a geohash. All geospatial queries will be against this
geohash index.

.. note::

   There may be only 1 geospatial index per collection. MongoDB may allow
   multiple geospatial indexes, but this behavior is unsupported and
   may produce undesireable behavior.

Modify Range
~~~~~~~~~~~~

Geospatial indexes have defaults that support global coordinate data
(i.e. latidude and longitude for points on Earth.) The index is
bounded by the boundaries. If you insert documents with
coordinate pairs outside of this boundary, MongoDB will return an
error and reject these documents. The boundaries, by
default, are between -180 inclusive, and 180
non-inclusive. [#non-inclusive]_ the same as used for global coordinates.

To modify the bounds of the index, use the ``min`` and ``max`` operations
with the :func:`ensureIndex() <db.collection.ensureIndex()>`
operation:

.. code-block:: javascript

   db.collection.ensureIndex( { <location field> : "2d" } , 
                              { min : <lower bound> , max : <upper bound> } )

For example:

.. code-block:: javascript

   db.example.ensureIndex( { loc : "2d" } , 
                           { min : Â­90 , max : 90 } )

Precision
~~~~~~~~~

Geospatial indexes record precision, or resolution, in "bits", which
is configurable during index creation.

If a geospatial index has more bits, then the more precise your index
will be. An index with fewer bits will be faster to query. For more
information, please refer to :doc:`Geospatial Indexes
</core/geospatial-indexes>`

You can change the precision of the geospatial index by
using the bits option when you use the :func:`ensureIndex()
<db.command.ensureIndex()>` function.

MongoDB allocates 26 bits by default, but allows a maximum of 32
bits. You may use less bits if your geospatial data has less precision
or if you would like faster queries, at the expense of precision.

.. code-block:: javascript

   db.collection.ensureIndex( {<location field>: "2d"} , 
                              { bits: <bit precision> } )

Compound Indexes
~~~~~~~~~~~~~~~~

By using compound indexes, MongoDB can use this index for a larger
portion of operations, which will improve performance. For many
queries, applications need to filter both by location and by another
field. To support these queries, MongoDB permits :term:`compound
indexes` where one component is geospatial data, and other components
store related data. By using compound indexes, geospatial queries with
this component will be accelerated.

.. TODO lead in restaurant example "query all restaurants near a target"

For example, if you have a collection of data that describes
restaurants' location and type, most queries will be about
the restaurant location and type.

.. TODO work out this example 

This is the prototype of the compound index command:

.. code-block:: javascript

   db.collection.ensureIndex( { <location field> : "2d" , 
                                <field> : 1 } );

For example:

.. code-block:: javascript

   db.example.ensureIndex( { location : "2d" , 
                             storeCategory : 1 } );

Geospatial Haystacking
~~~~~~~~~~~~~~~~~~~~~~

Geospatial haystack makes it possible to build a special ``bucket``
collection that can better support queries that operate within a
limited area. For more information, please refer to :doc:`Geospatial
Indexes </core/geospatial-indexes>`

Build a geospatial index and specify the ``geoHaystack`` for the
location field and a ``bucketSize`` parameter . The ``bucketSize``
parameter determines the granularity of the bucket index. A
``bucketSize`` of 1 creates an index where keys within 1 unit of
longitude or latitude are stored in the same bucket.

.. code-block:: javascript

   db.collection.ensureIndex({ <location field> : "geoHaystack", type : 1 }, 
                             { bucketSize : <bucket value> })

.. TODO redo this example
For example, if we want to index all restaurants in a particular area with a
given maximum distance of 6 degrees longitude-latitude to accelerate
searches in this area, set the index by the following command:

.. code-block:: javascript

   db.example.ensureIndex({ loc: "geoHaystack", type: 1} , 
                          { bucketSize : 6 } )

.. TODO verify original wiki: by default, there is a 50 document result limit:
.. this is different than $near (which returns 100 by default)

Querying
--------

There are specific querying options to use with geospatial
queries. You can query using the general :func:`find` function or the
specialized :dbcommand:`geoNear` command. The :dbcommand:`geoNear`
command is functionally the same as using the :func:`find` function
with geospatial options. The additional benefit of
:dbcommand:`geoNear` is that it provides additional geospatial
information in the return document.

Exact matches
~~~~~~~~~~~~~

The index can be queried directly for an exact match:

.. code-block:: javascript

  db.collection.find( { <location field>: [x,y] } )

.. TODO is there a geoNear/geoSearch equivalent?

For example:

.. code-block:: javascript

  db.example.find( { loc: [-74, 40.74] } )

This will return any indexed points that are at [-74,40.74].

.. _geospatial-query-near:

Near
~~~~

.. TODO express relationship between $near and geoNear

The :operator:`$near` operator returns the 100 closest points to ``[x,y]`` sorted
by distance.

.. code-block:: javascript

   db.collection.find( { <location field>: { $near : [x,y] } } )

OR

.. code-block:: javascript

   db.runCommand( {geoNear: "collection", near: [x,y] } )

For example:

.. code-block:: javascript

   db.example.find( { loc: { $near : [-74, 40.74] } } )

OR

.. code-block:: javascript

   db.runCommand( {geoNear: "example", near: [-74,40.74] } )

The default limit to return is 100. To limit the number of points
further, use the :func:`limit() <cursor.limit()>` function with
:func:`find` or :option:`num` with geoNear.

.. code-block:: javascript

   db.collection.find( { <location field>: { $near : [x,y] } } ).limit(n)

.. code-block:: javascript

   db.runCommand( {geoNear: "collection", near: [x,y], num: z } )   

For example:

.. code-block:: javascript

   db.example.find( { loc: { $near : [-74, 40.74] } } ).limit(20)

OR

.. code-block:: javascript

   db.runCommand( {geoNear: "collection", near: [-74, 40.74], num: 20 } )

To limit searches near a point with a particular distance you can use
:operator:`$maxDistance` with the :func:`near` function to limit the search
to a maximum distance for a particular area.

.. code-block:: javascript

  db.collection.find( { <location field>: { $near: [x,y] } , $maxDistance : z } )

  OR

  db.runCommand( { geoNear: "collection", near: [x,y], maxDistance: z } )

The distance specified in maxDistance is in the same units as the
coordinate system specifed. If the indexed region is in meters, the
distance unit is also in meters.

.. TODO confirm distance unit

Within
~~~~~~

The :operator:`$within` operator will return points within shapes such
as a circle, box, or polygon. Results from :operator:`$within` are
faster than from :operator:`$near` because they are not sorted by
distance.

.. code-block:: javascript

   db.collection.find( { <location field> : { "$within" : 
                       { <shape> : <shape dimentions> } } 
		       } )

To query within a circle, specify the center of the circle and the
radius for the :option:`$circle` option.

.. code-block:: javascript

   center = [-74, 40.74]
   radius = 10

   db.example.find( { "location" : { "$within" : { "$center" : [center, radius] } } } )

.. COMMENT - are length measurements based on the coordinate system (like maxDistance?)

To query within a box, specify the lower-left and upper-right corners
of the box.

.. code-block:: javascript

   box = [ [0, 0] , [5, 5] ]

   db.example.find( { "location" : { "$within" : { "$box" : box } } } )

To query within a polygon, specify a polygon by a multi-dimensional
array. The last point in the array is automatically connected to the
first point in the polygon.

.. code-block:: javascript

   polygon = [ [4,0], [3,2], [2,3], [2,4], [4,5], [6,4], [6,3], [5,2] ]

   db.places.find({ "location" : { "$within" : { "$polygon" : polygon } } })

.. versionchange:: 1.9

   For MongoDB versions before 1.9, polygon searches are not supported.


Data Representation
-------------------

Flat System
~~~~~~~~~~~

To use the flat system, you would query geospatial data using the
standard query functions.

Spherical System
~~~~~~~~~~~~~~~~

To use the spherical system, you have to ensure that location data is
in latitude-longitude oder in a 2D array. The spherical functions will 
not read the field name (i.e. [ long: x, lat:y ] will produce
undesirable results.)

for :dbcommand:`geoNear`: add ``{spherical:true}`` option.

for :func:`find` use the equivalent operators:

- near: :option:`$nearSphere`

- center: :option:`$centerSphere`

.. TODO write up and move below to geoNear command section.

Additional Diagnostics information
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(This section might be better in the commands page? This is getting
quite detailed)

?? What are the diagnostic info from the geoNear command? 

"results" list
per result details:
"dis"
"obj"

"stats"
  "time" -> time for query results
  "objectsLoaded" -> number of objects returned from this query (? why
  does the example have 2 listed?)
  "avgDistance" -> average distance of all the objects returned (? or
  loaded?)
